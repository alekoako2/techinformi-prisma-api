// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  departmentTranslation: (
    where?: DepartmentTranslationWhereInput
  ) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  employeePosition: (where?: EmployeePositionWhereInput) => Promise<boolean>;
  employeePositionTranslation: (
    where?: EmployeePositionTranslationWhereInput
  ) => Promise<boolean>;
  employeeTranslation: (
    where?: EmployeeTranslationWhereInput
  ) => Promise<boolean>;
  expert: (where?: ExpertWhereInput) => Promise<boolean>;
  expertTranslation: (where?: ExpertTranslationWhereInput) => Promise<boolean>;
  journal: (where?: JournalWhereInput) => Promise<boolean>;
  keyword: (where?: KeywordWhereInput) => Promise<boolean>;
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  news: (where?: NewsWhereInput) => Promise<boolean>;
  newsTranslation: (where?: NewsTranslationWhereInput) => Promise<boolean>;
  oecd: (where?: OecdWhereInput) => Promise<boolean>;
  oecdTranslation: (where?: OecdTranslationWhereInput) => Promise<boolean>;
  qrj: (where?: QrjWhereInput) => Promise<boolean>;
  qrjJournal: (where?: QrjJournalWhereInput) => Promise<boolean>;
  qrjJournalTranslation: (
    where?: QrjJournalTranslationWhereInput
  ) => Promise<boolean>;
  qrjPublication: (where?: QrjPublicationWhereInput) => Promise<boolean>;
  qrjPublicationTranslation: (
    where?: QrjPublicationTranslationWhereInput
  ) => Promise<boolean>;
  qrjTranslation: (where?: QrjTranslationWhereInput) => Promise<boolean>;
  researchProject: (where?: ResearchProjectWhereInput) => Promise<boolean>;
  researchProjectTranslation: (
    where?: ResearchProjectTranslationWhereInput
  ) => Promise<boolean>;
  technologyTransferAndInnovationOrganization: (
    where?: TechnologyTransferAndInnovationOrganizationWhereInput
  ) => Promise<boolean>;
  technologyTransferNetwork: (
    where?: TechnologyTransferNetworkWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userTranslation: (where?: UserTranslationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  departmentTranslation: (
    where: DepartmentTranslationWhereUniqueInput
  ) => DepartmentTranslationNullablePromise;
  departmentTranslations: (args?: {
    where?: DepartmentTranslationWhereInput;
    orderBy?: DepartmentTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DepartmentTranslation>;
  departmentTranslationsConnection: (args?: {
    where?: DepartmentTranslationWhereInput;
    orderBy?: DepartmentTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentTranslationConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeeNullablePromise;
  employees: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employee>;
  employeesConnection: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeConnectionPromise;
  employeePosition: (
    where: EmployeePositionWhereUniqueInput
  ) => EmployeePositionNullablePromise;
  employeePositions: (args?: {
    where?: EmployeePositionWhereInput;
    orderBy?: EmployeePositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmployeePosition>;
  employeePositionsConnection: (args?: {
    where?: EmployeePositionWhereInput;
    orderBy?: EmployeePositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeePositionConnectionPromise;
  employeePositionTranslation: (
    where: EmployeePositionTranslationWhereUniqueInput
  ) => EmployeePositionTranslationNullablePromise;
  employeePositionTranslations: (args?: {
    where?: EmployeePositionTranslationWhereInput;
    orderBy?: EmployeePositionTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmployeePositionTranslation>;
  employeePositionTranslationsConnection: (args?: {
    where?: EmployeePositionTranslationWhereInput;
    orderBy?: EmployeePositionTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeePositionTranslationConnectionPromise;
  employeeTranslation: (
    where: EmployeeTranslationWhereUniqueInput
  ) => EmployeeTranslationNullablePromise;
  employeeTranslations: (args?: {
    where?: EmployeeTranslationWhereInput;
    orderBy?: EmployeeTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmployeeTranslation>;
  employeeTranslationsConnection: (args?: {
    where?: EmployeeTranslationWhereInput;
    orderBy?: EmployeeTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeTranslationConnectionPromise;
  expert: (where: ExpertWhereUniqueInput) => ExpertNullablePromise;
  experts: (args?: {
    where?: ExpertWhereInput;
    orderBy?: ExpertOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Expert>;
  expertsConnection: (args?: {
    where?: ExpertWhereInput;
    orderBy?: ExpertOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpertConnectionPromise;
  expertTranslation: (
    where: ExpertTranslationWhereUniqueInput
  ) => ExpertTranslationNullablePromise;
  expertTranslations: (args?: {
    where?: ExpertTranslationWhereInput;
    orderBy?: ExpertTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpertTranslation>;
  expertTranslationsConnection: (args?: {
    where?: ExpertTranslationWhereInput;
    orderBy?: ExpertTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpertTranslationConnectionPromise;
  journal: (where: JournalWhereUniqueInput) => JournalNullablePromise;
  journals: (args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Journal>;
  journalsConnection: (args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JournalConnectionPromise;
  keyword: (where: KeywordWhereUniqueInput) => KeywordNullablePromise;
  keywords: (args?: {
    where?: KeywordWhereInput;
    orderBy?: KeywordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Keyword>;
  keywordsConnection: (args?: {
    where?: KeywordWhereInput;
    orderBy?: KeywordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => KeywordConnectionPromise;
  language: (where: LanguageWhereUniqueInput) => LanguageNullablePromise;
  languages: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Language>;
  languagesConnection: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LanguageConnectionPromise;
  news: (where: NewsWhereUniqueInput) => NewsNullablePromise;
  newses: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<News>;
  newsesConnection: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsConnectionPromise;
  newsTranslation: (
    where: NewsTranslationWhereUniqueInput
  ) => NewsTranslationNullablePromise;
  newsTranslations: (args?: {
    where?: NewsTranslationWhereInput;
    orderBy?: NewsTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NewsTranslation>;
  newsTranslationsConnection: (args?: {
    where?: NewsTranslationWhereInput;
    orderBy?: NewsTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsTranslationConnectionPromise;
  oecd: (where: OecdWhereUniqueInput) => OecdNullablePromise;
  oecds: (args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Oecd>;
  oecdsConnection: (args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OecdConnectionPromise;
  oecdTranslation: (
    where: OecdTranslationWhereUniqueInput
  ) => OecdTranslationNullablePromise;
  oecdTranslations: (args?: {
    where?: OecdTranslationWhereInput;
    orderBy?: OecdTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OecdTranslation>;
  oecdTranslationsConnection: (args?: {
    where?: OecdTranslationWhereInput;
    orderBy?: OecdTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OecdTranslationConnectionPromise;
  qrj: (where: QrjWhereUniqueInput) => QrjNullablePromise;
  qrjs: (args?: {
    where?: QrjWhereInput;
    orderBy?: QrjOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Qrj>;
  qrjsConnection: (args?: {
    where?: QrjWhereInput;
    orderBy?: QrjOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QrjConnectionPromise;
  qrjJournal: (where: QrjJournalWhereUniqueInput) => QrjJournalNullablePromise;
  qrjJournals: (args?: {
    where?: QrjJournalWhereInput;
    orderBy?: QrjJournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QrjJournal>;
  qrjJournalsConnection: (args?: {
    where?: QrjJournalWhereInput;
    orderBy?: QrjJournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QrjJournalConnectionPromise;
  qrjJournalTranslation: (
    where: QrjJournalTranslationWhereUniqueInput
  ) => QrjJournalTranslationNullablePromise;
  qrjJournalTranslations: (args?: {
    where?: QrjJournalTranslationWhereInput;
    orderBy?: QrjJournalTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QrjJournalTranslation>;
  qrjJournalTranslationsConnection: (args?: {
    where?: QrjJournalTranslationWhereInput;
    orderBy?: QrjJournalTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QrjJournalTranslationConnectionPromise;
  qrjPublication: (
    where: QrjPublicationWhereUniqueInput
  ) => QrjPublicationNullablePromise;
  qrjPublications: (args?: {
    where?: QrjPublicationWhereInput;
    orderBy?: QrjPublicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QrjPublication>;
  qrjPublicationsConnection: (args?: {
    where?: QrjPublicationWhereInput;
    orderBy?: QrjPublicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QrjPublicationConnectionPromise;
  qrjPublicationTranslation: (
    where: QrjPublicationTranslationWhereUniqueInput
  ) => QrjPublicationTranslationNullablePromise;
  qrjPublicationTranslations: (args?: {
    where?: QrjPublicationTranslationWhereInput;
    orderBy?: QrjPublicationTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QrjPublicationTranslation>;
  qrjPublicationTranslationsConnection: (args?: {
    where?: QrjPublicationTranslationWhereInput;
    orderBy?: QrjPublicationTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QrjPublicationTranslationConnectionPromise;
  qrjTranslation: (
    where: QrjTranslationWhereUniqueInput
  ) => QrjTranslationNullablePromise;
  qrjTranslations: (args?: {
    where?: QrjTranslationWhereInput;
    orderBy?: QrjTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QrjTranslation>;
  qrjTranslationsConnection: (args?: {
    where?: QrjTranslationWhereInput;
    orderBy?: QrjTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QrjTranslationConnectionPromise;
  researchProject: (
    where: ResearchProjectWhereUniqueInput
  ) => ResearchProjectNullablePromise;
  researchProjects: (args?: {
    where?: ResearchProjectWhereInput;
    orderBy?: ResearchProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ResearchProject>;
  researchProjectsConnection: (args?: {
    where?: ResearchProjectWhereInput;
    orderBy?: ResearchProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ResearchProjectConnectionPromise;
  researchProjectTranslation: (
    where: ResearchProjectTranslationWhereUniqueInput
  ) => ResearchProjectTranslationNullablePromise;
  researchProjectTranslations: (args?: {
    where?: ResearchProjectTranslationWhereInput;
    orderBy?: ResearchProjectTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ResearchProjectTranslation>;
  researchProjectTranslationsConnection: (args?: {
    where?: ResearchProjectTranslationWhereInput;
    orderBy?: ResearchProjectTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ResearchProjectTranslationConnectionPromise;
  technologyTransferAndInnovationOrganization: (
    where: TechnologyTransferAndInnovationOrganizationWhereUniqueInput
  ) => TechnologyTransferAndInnovationOrganizationNullablePromise;
  technologyTransferAndInnovationOrganizations: (args?: {
    where?: TechnologyTransferAndInnovationOrganizationWhereInput;
    orderBy?: TechnologyTransferAndInnovationOrganizationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TechnologyTransferAndInnovationOrganization>;
  technologyTransferAndInnovationOrganizationsConnection: (args?: {
    where?: TechnologyTransferAndInnovationOrganizationWhereInput;
    orderBy?: TechnologyTransferAndInnovationOrganizationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TechnologyTransferAndInnovationOrganizationConnectionPromise;
  technologyTransferNetwork: (
    where: TechnologyTransferNetworkWhereUniqueInput
  ) => TechnologyTransferNetworkNullablePromise;
  technologyTransferNetworks: (args?: {
    where?: TechnologyTransferNetworkWhereInput;
    orderBy?: TechnologyTransferNetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TechnologyTransferNetwork>;
  technologyTransferNetworksConnection: (args?: {
    where?: TechnologyTransferNetworkWhereInput;
    orderBy?: TechnologyTransferNetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TechnologyTransferNetworkConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userTranslation: (
    where: UserTranslationWhereUniqueInput
  ) => UserTranslationNullablePromise;
  userTranslations: (args?: {
    where?: UserTranslationWhereInput;
    orderBy?: UserTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserTranslation>;
  userTranslationsConnection: (args?: {
    where?: UserTranslationWhereInput;
    orderBy?: UserTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserTranslationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createDepartmentTranslation: (
    data: DepartmentTranslationCreateInput
  ) => DepartmentTranslationPromise;
  updateDepartmentTranslation: (args: {
    data: DepartmentTranslationUpdateInput;
    where: DepartmentTranslationWhereUniqueInput;
  }) => DepartmentTranslationPromise;
  updateManyDepartmentTranslations: (args: {
    data: DepartmentTranslationUpdateManyMutationInput;
    where?: DepartmentTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartmentTranslation: (args: {
    where: DepartmentTranslationWhereUniqueInput;
    create: DepartmentTranslationCreateInput;
    update: DepartmentTranslationUpdateInput;
  }) => DepartmentTranslationPromise;
  deleteDepartmentTranslation: (
    where: DepartmentTranslationWhereUniqueInput
  ) => DepartmentTranslationPromise;
  deleteManyDepartmentTranslations: (
    where?: DepartmentTranslationWhereInput
  ) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (args: {
    data: EmployeeUpdateInput;
    where: EmployeeWhereUniqueInput;
  }) => EmployeePromise;
  updateManyEmployees: (args: {
    data: EmployeeUpdateManyMutationInput;
    where?: EmployeeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployee: (args: {
    where: EmployeeWhereUniqueInput;
    create: EmployeeCreateInput;
    update: EmployeeUpdateInput;
  }) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createEmployeePosition: (
    data: EmployeePositionCreateInput
  ) => EmployeePositionPromise;
  updateEmployeePosition: (args: {
    data: EmployeePositionUpdateInput;
    where: EmployeePositionWhereUniqueInput;
  }) => EmployeePositionPromise;
  upsertEmployeePosition: (args: {
    where: EmployeePositionWhereUniqueInput;
    create: EmployeePositionCreateInput;
    update: EmployeePositionUpdateInput;
  }) => EmployeePositionPromise;
  deleteEmployeePosition: (
    where: EmployeePositionWhereUniqueInput
  ) => EmployeePositionPromise;
  deleteManyEmployeePositions: (
    where?: EmployeePositionWhereInput
  ) => BatchPayloadPromise;
  createEmployeePositionTranslation: (
    data: EmployeePositionTranslationCreateInput
  ) => EmployeePositionTranslationPromise;
  updateEmployeePositionTranslation: (args: {
    data: EmployeePositionTranslationUpdateInput;
    where: EmployeePositionTranslationWhereUniqueInput;
  }) => EmployeePositionTranslationPromise;
  updateManyEmployeePositionTranslations: (args: {
    data: EmployeePositionTranslationUpdateManyMutationInput;
    where?: EmployeePositionTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployeePositionTranslation: (args: {
    where: EmployeePositionTranslationWhereUniqueInput;
    create: EmployeePositionTranslationCreateInput;
    update: EmployeePositionTranslationUpdateInput;
  }) => EmployeePositionTranslationPromise;
  deleteEmployeePositionTranslation: (
    where: EmployeePositionTranslationWhereUniqueInput
  ) => EmployeePositionTranslationPromise;
  deleteManyEmployeePositionTranslations: (
    where?: EmployeePositionTranslationWhereInput
  ) => BatchPayloadPromise;
  createEmployeeTranslation: (
    data: EmployeeTranslationCreateInput
  ) => EmployeeTranslationPromise;
  updateEmployeeTranslation: (args: {
    data: EmployeeTranslationUpdateInput;
    where: EmployeeTranslationWhereUniqueInput;
  }) => EmployeeTranslationPromise;
  updateManyEmployeeTranslations: (args: {
    data: EmployeeTranslationUpdateManyMutationInput;
    where?: EmployeeTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployeeTranslation: (args: {
    where: EmployeeTranslationWhereUniqueInput;
    create: EmployeeTranslationCreateInput;
    update: EmployeeTranslationUpdateInput;
  }) => EmployeeTranslationPromise;
  deleteEmployeeTranslation: (
    where: EmployeeTranslationWhereUniqueInput
  ) => EmployeeTranslationPromise;
  deleteManyEmployeeTranslations: (
    where?: EmployeeTranslationWhereInput
  ) => BatchPayloadPromise;
  createExpert: (data: ExpertCreateInput) => ExpertPromise;
  updateExpert: (args: {
    data: ExpertUpdateInput;
    where: ExpertWhereUniqueInput;
  }) => ExpertPromise;
  updateManyExperts: (args: {
    data: ExpertUpdateManyMutationInput;
    where?: ExpertWhereInput;
  }) => BatchPayloadPromise;
  upsertExpert: (args: {
    where: ExpertWhereUniqueInput;
    create: ExpertCreateInput;
    update: ExpertUpdateInput;
  }) => ExpertPromise;
  deleteExpert: (where: ExpertWhereUniqueInput) => ExpertPromise;
  deleteManyExperts: (where?: ExpertWhereInput) => BatchPayloadPromise;
  createExpertTranslation: (
    data: ExpertTranslationCreateInput
  ) => ExpertTranslationPromise;
  updateExpertTranslation: (args: {
    data: ExpertTranslationUpdateInput;
    where: ExpertTranslationWhereUniqueInput;
  }) => ExpertTranslationPromise;
  updateManyExpertTranslations: (args: {
    data: ExpertTranslationUpdateManyMutationInput;
    where?: ExpertTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertExpertTranslation: (args: {
    where: ExpertTranslationWhereUniqueInput;
    create: ExpertTranslationCreateInput;
    update: ExpertTranslationUpdateInput;
  }) => ExpertTranslationPromise;
  deleteExpertTranslation: (
    where: ExpertTranslationWhereUniqueInput
  ) => ExpertTranslationPromise;
  deleteManyExpertTranslations: (
    where?: ExpertTranslationWhereInput
  ) => BatchPayloadPromise;
  createJournal: (data: JournalCreateInput) => JournalPromise;
  updateJournal: (args: {
    data: JournalUpdateInput;
    where: JournalWhereUniqueInput;
  }) => JournalPromise;
  updateManyJournals: (args: {
    data: JournalUpdateManyMutationInput;
    where?: JournalWhereInput;
  }) => BatchPayloadPromise;
  upsertJournal: (args: {
    where: JournalWhereUniqueInput;
    create: JournalCreateInput;
    update: JournalUpdateInput;
  }) => JournalPromise;
  deleteJournal: (where: JournalWhereUniqueInput) => JournalPromise;
  deleteManyJournals: (where?: JournalWhereInput) => BatchPayloadPromise;
  createKeyword: (data: KeywordCreateInput) => KeywordPromise;
  updateKeyword: (args: {
    data: KeywordUpdateInput;
    where: KeywordWhereUniqueInput;
  }) => KeywordPromise;
  updateManyKeywords: (args: {
    data: KeywordUpdateManyMutationInput;
    where?: KeywordWhereInput;
  }) => BatchPayloadPromise;
  upsertKeyword: (args: {
    where: KeywordWhereUniqueInput;
    create: KeywordCreateInput;
    update: KeywordUpdateInput;
  }) => KeywordPromise;
  deleteKeyword: (where: KeywordWhereUniqueInput) => KeywordPromise;
  deleteManyKeywords: (where?: KeywordWhereInput) => BatchPayloadPromise;
  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateLanguage: (args: {
    data: LanguageUpdateInput;
    where: LanguageWhereUniqueInput;
  }) => LanguagePromise;
  updateManyLanguages: (args: {
    data: LanguageUpdateManyMutationInput;
    where?: LanguageWhereInput;
  }) => BatchPayloadPromise;
  upsertLanguage: (args: {
    where: LanguageWhereUniqueInput;
    create: LanguageCreateInput;
    update: LanguageUpdateInput;
  }) => LanguagePromise;
  deleteLanguage: (where: LanguageWhereUniqueInput) => LanguagePromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createNews: (data: NewsCreateInput) => NewsPromise;
  updateNews: (args: {
    data: NewsUpdateInput;
    where: NewsWhereUniqueInput;
  }) => NewsPromise;
  upsertNews: (args: {
    where: NewsWhereUniqueInput;
    create: NewsCreateInput;
    update: NewsUpdateInput;
  }) => NewsPromise;
  deleteNews: (where: NewsWhereUniqueInput) => NewsPromise;
  deleteManyNewses: (where?: NewsWhereInput) => BatchPayloadPromise;
  createNewsTranslation: (
    data: NewsTranslationCreateInput
  ) => NewsTranslationPromise;
  updateNewsTranslation: (args: {
    data: NewsTranslationUpdateInput;
    where: NewsTranslationWhereUniqueInput;
  }) => NewsTranslationPromise;
  updateManyNewsTranslations: (args: {
    data: NewsTranslationUpdateManyMutationInput;
    where?: NewsTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertNewsTranslation: (args: {
    where: NewsTranslationWhereUniqueInput;
    create: NewsTranslationCreateInput;
    update: NewsTranslationUpdateInput;
  }) => NewsTranslationPromise;
  deleteNewsTranslation: (
    where: NewsTranslationWhereUniqueInput
  ) => NewsTranslationPromise;
  deleteManyNewsTranslations: (
    where?: NewsTranslationWhereInput
  ) => BatchPayloadPromise;
  createOecd: (data: OecdCreateInput) => OecdPromise;
  updateOecd: (args: {
    data: OecdUpdateInput;
    where: OecdWhereUniqueInput;
  }) => OecdPromise;
  updateManyOecds: (args: {
    data: OecdUpdateManyMutationInput;
    where?: OecdWhereInput;
  }) => BatchPayloadPromise;
  upsertOecd: (args: {
    where: OecdWhereUniqueInput;
    create: OecdCreateInput;
    update: OecdUpdateInput;
  }) => OecdPromise;
  deleteOecd: (where: OecdWhereUniqueInput) => OecdPromise;
  deleteManyOecds: (where?: OecdWhereInput) => BatchPayloadPromise;
  createOecdTranslation: (
    data: OecdTranslationCreateInput
  ) => OecdTranslationPromise;
  updateOecdTranslation: (args: {
    data: OecdTranslationUpdateInput;
    where: OecdTranslationWhereUniqueInput;
  }) => OecdTranslationPromise;
  updateManyOecdTranslations: (args: {
    data: OecdTranslationUpdateManyMutationInput;
    where?: OecdTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertOecdTranslation: (args: {
    where: OecdTranslationWhereUniqueInput;
    create: OecdTranslationCreateInput;
    update: OecdTranslationUpdateInput;
  }) => OecdTranslationPromise;
  deleteOecdTranslation: (
    where: OecdTranslationWhereUniqueInput
  ) => OecdTranslationPromise;
  deleteManyOecdTranslations: (
    where?: OecdTranslationWhereInput
  ) => BatchPayloadPromise;
  createQrj: (data: QrjCreateInput) => QrjPromise;
  updateQrj: (args: {
    data: QrjUpdateInput;
    where: QrjWhereUniqueInput;
  }) => QrjPromise;
  updateManyQrjs: (args: {
    data: QrjUpdateManyMutationInput;
    where?: QrjWhereInput;
  }) => BatchPayloadPromise;
  upsertQrj: (args: {
    where: QrjWhereUniqueInput;
    create: QrjCreateInput;
    update: QrjUpdateInput;
  }) => QrjPromise;
  deleteQrj: (where: QrjWhereUniqueInput) => QrjPromise;
  deleteManyQrjs: (where?: QrjWhereInput) => BatchPayloadPromise;
  createQrjJournal: (data: QrjJournalCreateInput) => QrjJournalPromise;
  updateQrjJournal: (args: {
    data: QrjJournalUpdateInput;
    where: QrjJournalWhereUniqueInput;
  }) => QrjJournalPromise;
  updateManyQrjJournals: (args: {
    data: QrjJournalUpdateManyMutationInput;
    where?: QrjJournalWhereInput;
  }) => BatchPayloadPromise;
  upsertQrjJournal: (args: {
    where: QrjJournalWhereUniqueInput;
    create: QrjJournalCreateInput;
    update: QrjJournalUpdateInput;
  }) => QrjJournalPromise;
  deleteQrjJournal: (where: QrjJournalWhereUniqueInput) => QrjJournalPromise;
  deleteManyQrjJournals: (where?: QrjJournalWhereInput) => BatchPayloadPromise;
  createQrjJournalTranslation: (
    data: QrjJournalTranslationCreateInput
  ) => QrjJournalTranslationPromise;
  updateQrjJournalTranslation: (args: {
    data: QrjJournalTranslationUpdateInput;
    where: QrjJournalTranslationWhereUniqueInput;
  }) => QrjJournalTranslationPromise;
  updateManyQrjJournalTranslations: (args: {
    data: QrjJournalTranslationUpdateManyMutationInput;
    where?: QrjJournalTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertQrjJournalTranslation: (args: {
    where: QrjJournalTranslationWhereUniqueInput;
    create: QrjJournalTranslationCreateInput;
    update: QrjJournalTranslationUpdateInput;
  }) => QrjJournalTranslationPromise;
  deleteQrjJournalTranslation: (
    where: QrjJournalTranslationWhereUniqueInput
  ) => QrjJournalTranslationPromise;
  deleteManyQrjJournalTranslations: (
    where?: QrjJournalTranslationWhereInput
  ) => BatchPayloadPromise;
  createQrjPublication: (
    data: QrjPublicationCreateInput
  ) => QrjPublicationPromise;
  updateQrjPublication: (args: {
    data: QrjPublicationUpdateInput;
    where: QrjPublicationWhereUniqueInput;
  }) => QrjPublicationPromise;
  updateManyQrjPublications: (args: {
    data: QrjPublicationUpdateManyMutationInput;
    where?: QrjPublicationWhereInput;
  }) => BatchPayloadPromise;
  upsertQrjPublication: (args: {
    where: QrjPublicationWhereUniqueInput;
    create: QrjPublicationCreateInput;
    update: QrjPublicationUpdateInput;
  }) => QrjPublicationPromise;
  deleteQrjPublication: (
    where: QrjPublicationWhereUniqueInput
  ) => QrjPublicationPromise;
  deleteManyQrjPublications: (
    where?: QrjPublicationWhereInput
  ) => BatchPayloadPromise;
  createQrjPublicationTranslation: (
    data: QrjPublicationTranslationCreateInput
  ) => QrjPublicationTranslationPromise;
  updateQrjPublicationTranslation: (args: {
    data: QrjPublicationTranslationUpdateInput;
    where: QrjPublicationTranslationWhereUniqueInput;
  }) => QrjPublicationTranslationPromise;
  updateManyQrjPublicationTranslations: (args: {
    data: QrjPublicationTranslationUpdateManyMutationInput;
    where?: QrjPublicationTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertQrjPublicationTranslation: (args: {
    where: QrjPublicationTranslationWhereUniqueInput;
    create: QrjPublicationTranslationCreateInput;
    update: QrjPublicationTranslationUpdateInput;
  }) => QrjPublicationTranslationPromise;
  deleteQrjPublicationTranslation: (
    where: QrjPublicationTranslationWhereUniqueInput
  ) => QrjPublicationTranslationPromise;
  deleteManyQrjPublicationTranslations: (
    where?: QrjPublicationTranslationWhereInput
  ) => BatchPayloadPromise;
  createQrjTranslation: (
    data: QrjTranslationCreateInput
  ) => QrjTranslationPromise;
  updateQrjTranslation: (args: {
    data: QrjTranslationUpdateInput;
    where: QrjTranslationWhereUniqueInput;
  }) => QrjTranslationPromise;
  updateManyQrjTranslations: (args: {
    data: QrjTranslationUpdateManyMutationInput;
    where?: QrjTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertQrjTranslation: (args: {
    where: QrjTranslationWhereUniqueInput;
    create: QrjTranslationCreateInput;
    update: QrjTranslationUpdateInput;
  }) => QrjTranslationPromise;
  deleteQrjTranslation: (
    where: QrjTranslationWhereUniqueInput
  ) => QrjTranslationPromise;
  deleteManyQrjTranslations: (
    where?: QrjTranslationWhereInput
  ) => BatchPayloadPromise;
  createResearchProject: (
    data: ResearchProjectCreateInput
  ) => ResearchProjectPromise;
  updateResearchProject: (args: {
    data: ResearchProjectUpdateInput;
    where: ResearchProjectWhereUniqueInput;
  }) => ResearchProjectPromise;
  updateManyResearchProjects: (args: {
    data: ResearchProjectUpdateManyMutationInput;
    where?: ResearchProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertResearchProject: (args: {
    where: ResearchProjectWhereUniqueInput;
    create: ResearchProjectCreateInput;
    update: ResearchProjectUpdateInput;
  }) => ResearchProjectPromise;
  deleteResearchProject: (
    where: ResearchProjectWhereUniqueInput
  ) => ResearchProjectPromise;
  deleteManyResearchProjects: (
    where?: ResearchProjectWhereInput
  ) => BatchPayloadPromise;
  createResearchProjectTranslation: (
    data: ResearchProjectTranslationCreateInput
  ) => ResearchProjectTranslationPromise;
  updateResearchProjectTranslation: (args: {
    data: ResearchProjectTranslationUpdateInput;
    where: ResearchProjectTranslationWhereUniqueInput;
  }) => ResearchProjectTranslationPromise;
  updateManyResearchProjectTranslations: (args: {
    data: ResearchProjectTranslationUpdateManyMutationInput;
    where?: ResearchProjectTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertResearchProjectTranslation: (args: {
    where: ResearchProjectTranslationWhereUniqueInput;
    create: ResearchProjectTranslationCreateInput;
    update: ResearchProjectTranslationUpdateInput;
  }) => ResearchProjectTranslationPromise;
  deleteResearchProjectTranslation: (
    where: ResearchProjectTranslationWhereUniqueInput
  ) => ResearchProjectTranslationPromise;
  deleteManyResearchProjectTranslations: (
    where?: ResearchProjectTranslationWhereInput
  ) => BatchPayloadPromise;
  createTechnologyTransferAndInnovationOrganization: (
    data: TechnologyTransferAndInnovationOrganizationCreateInput
  ) => TechnologyTransferAndInnovationOrganizationPromise;
  updateTechnologyTransferAndInnovationOrganization: (args: {
    data: TechnologyTransferAndInnovationOrganizationUpdateInput;
    where: TechnologyTransferAndInnovationOrganizationWhereUniqueInput;
  }) => TechnologyTransferAndInnovationOrganizationPromise;
  updateManyTechnologyTransferAndInnovationOrganizations: (args: {
    data: TechnologyTransferAndInnovationOrganizationUpdateManyMutationInput;
    where?: TechnologyTransferAndInnovationOrganizationWhereInput;
  }) => BatchPayloadPromise;
  upsertTechnologyTransferAndInnovationOrganization: (args: {
    where: TechnologyTransferAndInnovationOrganizationWhereUniqueInput;
    create: TechnologyTransferAndInnovationOrganizationCreateInput;
    update: TechnologyTransferAndInnovationOrganizationUpdateInput;
  }) => TechnologyTransferAndInnovationOrganizationPromise;
  deleteTechnologyTransferAndInnovationOrganization: (
    where: TechnologyTransferAndInnovationOrganizationWhereUniqueInput
  ) => TechnologyTransferAndInnovationOrganizationPromise;
  deleteManyTechnologyTransferAndInnovationOrganizations: (
    where?: TechnologyTransferAndInnovationOrganizationWhereInput
  ) => BatchPayloadPromise;
  createTechnologyTransferNetwork: (
    data: TechnologyTransferNetworkCreateInput
  ) => TechnologyTransferNetworkPromise;
  updateTechnologyTransferNetwork: (args: {
    data: TechnologyTransferNetworkUpdateInput;
    where: TechnologyTransferNetworkWhereUniqueInput;
  }) => TechnologyTransferNetworkPromise;
  updateManyTechnologyTransferNetworks: (args: {
    data: TechnologyTransferNetworkUpdateManyMutationInput;
    where?: TechnologyTransferNetworkWhereInput;
  }) => BatchPayloadPromise;
  upsertTechnologyTransferNetwork: (args: {
    where: TechnologyTransferNetworkWhereUniqueInput;
    create: TechnologyTransferNetworkCreateInput;
    update: TechnologyTransferNetworkUpdateInput;
  }) => TechnologyTransferNetworkPromise;
  deleteTechnologyTransferNetwork: (
    where: TechnologyTransferNetworkWhereUniqueInput
  ) => TechnologyTransferNetworkPromise;
  deleteManyTechnologyTransferNetworks: (
    where?: TechnologyTransferNetworkWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserTranslation: (
    data: UserTranslationCreateInput
  ) => UserTranslationPromise;
  updateUserTranslation: (args: {
    data: UserTranslationUpdateInput;
    where: UserTranslationWhereUniqueInput;
  }) => UserTranslationPromise;
  updateManyUserTranslations: (args: {
    data: UserTranslationUpdateManyMutationInput;
    where?: UserTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertUserTranslation: (args: {
    where: UserTranslationWhereUniqueInput;
    create: UserTranslationCreateInput;
    update: UserTranslationUpdateInput;
  }) => UserTranslationPromise;
  deleteUserTranslation: (
    where: UserTranslationWhereUniqueInput
  ) => UserTranslationPromise;
  deleteManyUserTranslations: (
    where?: UserTranslationWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  departmentTranslation: (
    where?: DepartmentTranslationSubscriptionWhereInput
  ) => DepartmentTranslationSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  employeePosition: (
    where?: EmployeePositionSubscriptionWhereInput
  ) => EmployeePositionSubscriptionPayloadSubscription;
  employeePositionTranslation: (
    where?: EmployeePositionTranslationSubscriptionWhereInput
  ) => EmployeePositionTranslationSubscriptionPayloadSubscription;
  employeeTranslation: (
    where?: EmployeeTranslationSubscriptionWhereInput
  ) => EmployeeTranslationSubscriptionPayloadSubscription;
  expert: (
    where?: ExpertSubscriptionWhereInput
  ) => ExpertSubscriptionPayloadSubscription;
  expertTranslation: (
    where?: ExpertTranslationSubscriptionWhereInput
  ) => ExpertTranslationSubscriptionPayloadSubscription;
  journal: (
    where?: JournalSubscriptionWhereInput
  ) => JournalSubscriptionPayloadSubscription;
  keyword: (
    where?: KeywordSubscriptionWhereInput
  ) => KeywordSubscriptionPayloadSubscription;
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  news: (
    where?: NewsSubscriptionWhereInput
  ) => NewsSubscriptionPayloadSubscription;
  newsTranslation: (
    where?: NewsTranslationSubscriptionWhereInput
  ) => NewsTranslationSubscriptionPayloadSubscription;
  oecd: (
    where?: OecdSubscriptionWhereInput
  ) => OecdSubscriptionPayloadSubscription;
  oecdTranslation: (
    where?: OecdTranslationSubscriptionWhereInput
  ) => OecdTranslationSubscriptionPayloadSubscription;
  qrj: (
    where?: QrjSubscriptionWhereInput
  ) => QrjSubscriptionPayloadSubscription;
  qrjJournal: (
    where?: QrjJournalSubscriptionWhereInput
  ) => QrjJournalSubscriptionPayloadSubscription;
  qrjJournalTranslation: (
    where?: QrjJournalTranslationSubscriptionWhereInput
  ) => QrjJournalTranslationSubscriptionPayloadSubscription;
  qrjPublication: (
    where?: QrjPublicationSubscriptionWhereInput
  ) => QrjPublicationSubscriptionPayloadSubscription;
  qrjPublicationTranslation: (
    where?: QrjPublicationTranslationSubscriptionWhereInput
  ) => QrjPublicationTranslationSubscriptionPayloadSubscription;
  qrjTranslation: (
    where?: QrjTranslationSubscriptionWhereInput
  ) => QrjTranslationSubscriptionPayloadSubscription;
  researchProject: (
    where?: ResearchProjectSubscriptionWhereInput
  ) => ResearchProjectSubscriptionPayloadSubscription;
  researchProjectTranslation: (
    where?: ResearchProjectTranslationSubscriptionWhereInput
  ) => ResearchProjectTranslationSubscriptionPayloadSubscription;
  technologyTransferAndInnovationOrganization: (
    where?: TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput
  ) => TechnologyTransferAndInnovationOrganizationSubscriptionPayloadSubscription;
  technologyTransferNetwork: (
    where?: TechnologyTransferNetworkSubscriptionWhereInput
  ) => TechnologyTransferNetworkSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userTranslation: (
    where?: UserTranslationSubscriptionWhereInput
  ) => UserTranslationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LanguageCode = "KA" | "EN" | "FR" | "ES" | "IT" | "RU" | "DE";

export type DepartmentTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Gender = "MALE" | "FEMALE";

export type EmployeePositionTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type EmployeeTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "tel_ASC"
  | "tel_DESC";

export type EmployeePositionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExpertTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "fullName_ASC"
  | "fullName_DESC"
  | "qualification_ASC"
  | "qualification_DESC"
  | "academicDegree_ASC"
  | "academicDegree_DESC"
  | "specialization_ASC"
  | "specialization_DESC"
  | "workingPlace_ASC"
  | "workingPlace_DESC"
  | "position_ASC"
  | "position_DESC";

export type Role = "ADMIN" | "EDITOR" | "CUSTOMER";

export type OecdOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "code_ASC"
  | "code_DESC";

export type OecdTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type NewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NewsTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "content_ASC"
  | "content_DESC";

export type UserTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC";

export type LanguageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC";

export type ExpertOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "workExperience_ASC"
  | "workExperience_DESC"
  | "inpDate_ASC"
  | "inpDate_DESC"
  | "email_ASC"
  | "email_DESC"
  | "web_ASC"
  | "web_DESC"
  | "tel_ASC"
  | "tel_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "publications_ASC"
  | "publications_DESC";

export type QrjTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "address_ASC"
  | "address_DESC";

export type JournalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pubNumber_ASC"
  | "pubNumber_DESC";

export type KeywordOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type QrjOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC";

export type QrjJournalTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC";

export type QrjJournalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "code_ASC"
  | "code_DESC";

export type QrjPublicationTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "publicationAuthor_ASC"
  | "publicationAuthor_DESC"
  | "publicationLang_ASC"
  | "publicationLang_DESC"
  | "abstract_ASC"
  | "abstract_DESC";

export type QrjPublicationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "index_ASC"
  | "index_DESC"
  | "edited_ASC"
  | "edited_DESC"
  | "year_ASC"
  | "year_DESC"
  | "number_ASC"
  | "number_DESC"
  | "pages_ASC"
  | "pages_DESC"
  | "doiUrl_ASC"
  | "doiUrl_DESC"
  | "inputDate_ASC"
  | "inputDate_DESC";

export type ResearchProjectTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC";

export type ResearchProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "inpDate_ASC"
  | "inpDate_DESC"
  | "regDate_ASC"
  | "regDate_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "regNumb_ASC"
  | "regNumb_DESC"
  | "research_ASC"
  | "research_DESC"
  | "researchDirection_ASC"
  | "researchDirection_DESC"
  | "researchExecutionBasis_ASC"
  | "researchExecutionBasis_DESC"
  | "abstract_ASC"
  | "abstract_DESC"
  | "annotation_ASC"
  | "annotation_DESC"
  | "budget_ASC"
  | "budget_DESC"
  | "organizationName_ASC"
  | "organizationName_DESC"
  | "organizationShortName_ASC"
  | "organizationShortName_DESC"
  | "organizationCode_ASC"
  | "organizationCode_DESC"
  | "organizationHead_ASC"
  | "organizationHead_DESC"
  | "organizationCity_ASC"
  | "organizationCity_DESC"
  | "organizationAddress_ASC"
  | "organizationAddress_DESC"
  | "organizationIndex_ASC"
  | "organizationIndex_DESC"
  | "organizationTel_ASC"
  | "organizationTel_DESC"
  | "organizationWeb_ASC"
  | "organizationWeb_DESC"
  | "participatingInstitutionName_ASC"
  | "participatingInstitutionName_DESC"
  | "participatingInstitutionCountryCity_ASC"
  | "participatingInstitutionCountryCity_DESC"
  | "participatingInstitutionTel_ASC"
  | "participatingInstitutionTel_DESC"
  | "participatingInstitutionEmail_ASC"
  | "participatingInstitutionEmail_DESC"
  | "participatingInstitutionWeb_ASC"
  | "participatingInstitutionWeb_DESC"
  | "leaderName_ASC"
  | "leaderName_DESC"
  | "leaderPosition_ASC"
  | "leaderPosition_DESC"
  | "leaderAcademicDegree_ASC"
  | "leaderAcademicDegree_DESC"
  | "leaderTel_ASC"
  | "leaderTel_DESC"
  | "leaderMobile_ASC"
  | "leaderMobile_DESC"
  | "leaderEmail_ASC"
  | "leaderEmail_DESC"
  | "researchExecutors_ASC"
  | "researchExecutors_DESC"
  | "financing_ASC"
  | "financing_DESC"
  | "note_ASC"
  | "note_DESC"
  | "pincode_ASC"
  | "pincode_DESC";

export type TechnologyTransferAndInnovationOrganizationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "url_ASC"
  | "url_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "region_ASC"
  | "region_DESC";

export type TechnologyTransferNetworkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "url_ASC"
  | "url_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "region_ASC"
  | "region_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DepartmentTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  department?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentTranslationWhereInput[] | DepartmentTranslationWhereInput
  >;
  OR?: Maybe<
    DepartmentTranslationWhereInput[] | DepartmentTranslationWhereInput
  >;
  NOT?: Maybe<
    DepartmentTranslationWhereInput[] | DepartmentTranslationWhereInput
  >;
}

export interface LanguageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  code?: Maybe<LanguageCode>;
  code_not?: Maybe<LanguageCode>;
  code_in?: Maybe<LanguageCode[] | LanguageCode>;
  code_not_in?: Maybe<LanguageCode[] | LanguageCode>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  OR?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  NOT?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
}

export interface DepartmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  translation_every?: Maybe<DepartmentTranslationWhereInput>;
  translation_some?: Maybe<DepartmentTranslationWhereInput>;
  translation_none?: Maybe<DepartmentTranslationWhereInput>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export type DepartmentTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EmployeePositionTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  position?: Maybe<EmployeePositionWhereInput>;
  AND?: Maybe<
    | EmployeePositionTranslationWhereInput[]
    | EmployeePositionTranslationWhereInput
  >;
  OR?: Maybe<
    | EmployeePositionTranslationWhereInput[]
    | EmployeePositionTranslationWhereInput
  >;
  NOT?: Maybe<
    | EmployeePositionTranslationWhereInput[]
    | EmployeePositionTranslationWhereInput
  >;
}

export interface EmployeePositionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  translation_every?: Maybe<EmployeePositionTranslationWhereInput>;
  translation_some?: Maybe<EmployeePositionTranslationWhereInput>;
  translation_none?: Maybe<EmployeePositionTranslationWhereInput>;
  AND?: Maybe<EmployeePositionWhereInput[] | EmployeePositionWhereInput>;
  OR?: Maybe<EmployeePositionWhereInput[] | EmployeePositionWhereInput>;
  NOT?: Maybe<EmployeePositionWhereInput[] | EmployeePositionWhereInput>;
}

export interface EmployeeTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<EmployeeTranslationWhereInput[] | EmployeeTranslationWhereInput>;
  OR?: Maybe<EmployeeTranslationWhereInput[] | EmployeeTranslationWhereInput>;
  NOT?: Maybe<EmployeeTranslationWhereInput[] | EmployeeTranslationWhereInput>;
}

export interface EmployeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  tel?: Maybe<String>;
  tel_not?: Maybe<String>;
  tel_in?: Maybe<String[] | String>;
  tel_not_in?: Maybe<String[] | String>;
  tel_lt?: Maybe<String>;
  tel_lte?: Maybe<String>;
  tel_gt?: Maybe<String>;
  tel_gte?: Maybe<String>;
  tel_contains?: Maybe<String>;
  tel_not_contains?: Maybe<String>;
  tel_starts_with?: Maybe<String>;
  tel_not_starts_with?: Maybe<String>;
  tel_ends_with?: Maybe<String>;
  tel_not_ends_with?: Maybe<String>;
  department?: Maybe<DepartmentWhereInput>;
  position?: Maybe<EmployeePositionWhereInput>;
  translation_every?: Maybe<EmployeeTranslationWhereInput>;
  translation_some?: Maybe<EmployeeTranslationWhereInput>;
  translation_none?: Maybe<EmployeeTranslationWhereInput>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  OR?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  NOT?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export type EmployeePositionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EmployeePositionTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type EmployeeTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExpertWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExpertTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  fullName?: Maybe<String>;
  fullName_not?: Maybe<String>;
  fullName_in?: Maybe<String[] | String>;
  fullName_not_in?: Maybe<String[] | String>;
  fullName_lt?: Maybe<String>;
  fullName_lte?: Maybe<String>;
  fullName_gt?: Maybe<String>;
  fullName_gte?: Maybe<String>;
  fullName_contains?: Maybe<String>;
  fullName_not_contains?: Maybe<String>;
  fullName_starts_with?: Maybe<String>;
  fullName_not_starts_with?: Maybe<String>;
  fullName_ends_with?: Maybe<String>;
  fullName_not_ends_with?: Maybe<String>;
  qualification?: Maybe<String>;
  qualification_not?: Maybe<String>;
  qualification_in?: Maybe<String[] | String>;
  qualification_not_in?: Maybe<String[] | String>;
  qualification_lt?: Maybe<String>;
  qualification_lte?: Maybe<String>;
  qualification_gt?: Maybe<String>;
  qualification_gte?: Maybe<String>;
  qualification_contains?: Maybe<String>;
  qualification_not_contains?: Maybe<String>;
  qualification_starts_with?: Maybe<String>;
  qualification_not_starts_with?: Maybe<String>;
  qualification_ends_with?: Maybe<String>;
  qualification_not_ends_with?: Maybe<String>;
  academicDegree?: Maybe<String>;
  academicDegree_not?: Maybe<String>;
  academicDegree_in?: Maybe<String[] | String>;
  academicDegree_not_in?: Maybe<String[] | String>;
  academicDegree_lt?: Maybe<String>;
  academicDegree_lte?: Maybe<String>;
  academicDegree_gt?: Maybe<String>;
  academicDegree_gte?: Maybe<String>;
  academicDegree_contains?: Maybe<String>;
  academicDegree_not_contains?: Maybe<String>;
  academicDegree_starts_with?: Maybe<String>;
  academicDegree_not_starts_with?: Maybe<String>;
  academicDegree_ends_with?: Maybe<String>;
  academicDegree_not_ends_with?: Maybe<String>;
  specialization?: Maybe<String>;
  specialization_not?: Maybe<String>;
  specialization_in?: Maybe<String[] | String>;
  specialization_not_in?: Maybe<String[] | String>;
  specialization_lt?: Maybe<String>;
  specialization_lte?: Maybe<String>;
  specialization_gt?: Maybe<String>;
  specialization_gte?: Maybe<String>;
  specialization_contains?: Maybe<String>;
  specialization_not_contains?: Maybe<String>;
  specialization_starts_with?: Maybe<String>;
  specialization_not_starts_with?: Maybe<String>;
  specialization_ends_with?: Maybe<String>;
  specialization_not_ends_with?: Maybe<String>;
  workingPlace?: Maybe<String>;
  workingPlace_not?: Maybe<String>;
  workingPlace_in?: Maybe<String[] | String>;
  workingPlace_not_in?: Maybe<String[] | String>;
  workingPlace_lt?: Maybe<String>;
  workingPlace_lte?: Maybe<String>;
  workingPlace_gt?: Maybe<String>;
  workingPlace_gte?: Maybe<String>;
  workingPlace_contains?: Maybe<String>;
  workingPlace_not_contains?: Maybe<String>;
  workingPlace_starts_with?: Maybe<String>;
  workingPlace_not_starts_with?: Maybe<String>;
  workingPlace_ends_with?: Maybe<String>;
  workingPlace_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<ExpertTranslationWhereInput[] | ExpertTranslationWhereInput>;
  OR?: Maybe<ExpertTranslationWhereInput[] | ExpertTranslationWhereInput>;
  NOT?: Maybe<ExpertTranslationWhereInput[] | ExpertTranslationWhereInput>;
}

export interface OecdWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  translation_every?: Maybe<OecdTranslationWhereInput>;
  translation_some?: Maybe<OecdTranslationWhereInput>;
  translation_none?: Maybe<OecdTranslationWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<OecdWhereInput[] | OecdWhereInput>;
  OR?: Maybe<OecdWhereInput[] | OecdWhereInput>;
  NOT?: Maybe<OecdWhereInput[] | OecdWhereInput>;
}

export interface OecdTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<OecdTranslationWhereInput[] | OecdTranslationWhereInput>;
  OR?: Maybe<OecdTranslationWhereInput[] | OecdTranslationWhereInput>;
  NOT?: Maybe<OecdTranslationWhereInput[] | OecdTranslationWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  news_every?: Maybe<NewsWhereInput>;
  news_some?: Maybe<NewsWhereInput>;
  news_none?: Maybe<NewsWhereInput>;
  oecds_every?: Maybe<OecdWhereInput>;
  oecds_some?: Maybe<OecdWhereInput>;
  oecds_none?: Maybe<OecdWhereInput>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  translation_every?: Maybe<UserTranslationWhereInput>;
  translation_some?: Maybe<UserTranslationWhereInput>;
  translation_none?: Maybe<UserTranslationWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface NewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  translation_every?: Maybe<NewsTranslationWhereInput>;
  translation_some?: Maybe<NewsTranslationWhereInput>;
  translation_none?: Maybe<NewsTranslationWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  OR?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  NOT?: Maybe<NewsWhereInput[] | NewsWhereInput>;
}

export interface NewsTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<NewsTranslationWhereInput[] | NewsTranslationWhereInput>;
  OR?: Maybe<NewsTranslationWhereInput[] | NewsTranslationWhereInput>;
  NOT?: Maybe<NewsTranslationWhereInput[] | NewsTranslationWhereInput>;
}

export interface UserTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<UserTranslationWhereInput[] | UserTranslationWhereInput>;
  OR?: Maybe<UserTranslationWhereInput[] | UserTranslationWhereInput>;
  NOT?: Maybe<UserTranslationWhereInput[] | UserTranslationWhereInput>;
}

export interface ExpertWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  workExperience?: Maybe<String>;
  workExperience_not?: Maybe<String>;
  workExperience_in?: Maybe<String[] | String>;
  workExperience_not_in?: Maybe<String[] | String>;
  workExperience_lt?: Maybe<String>;
  workExperience_lte?: Maybe<String>;
  workExperience_gt?: Maybe<String>;
  workExperience_gte?: Maybe<String>;
  workExperience_contains?: Maybe<String>;
  workExperience_not_contains?: Maybe<String>;
  workExperience_starts_with?: Maybe<String>;
  workExperience_not_starts_with?: Maybe<String>;
  workExperience_ends_with?: Maybe<String>;
  workExperience_not_ends_with?: Maybe<String>;
  inpDate?: Maybe<DateTimeInput>;
  inpDate_not?: Maybe<DateTimeInput>;
  inpDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  inpDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  inpDate_lt?: Maybe<DateTimeInput>;
  inpDate_lte?: Maybe<DateTimeInput>;
  inpDate_gt?: Maybe<DateTimeInput>;
  inpDate_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  web?: Maybe<String>;
  web_not?: Maybe<String>;
  web_in?: Maybe<String[] | String>;
  web_not_in?: Maybe<String[] | String>;
  web_lt?: Maybe<String>;
  web_lte?: Maybe<String>;
  web_gt?: Maybe<String>;
  web_gte?: Maybe<String>;
  web_contains?: Maybe<String>;
  web_not_contains?: Maybe<String>;
  web_starts_with?: Maybe<String>;
  web_not_starts_with?: Maybe<String>;
  web_ends_with?: Maybe<String>;
  web_not_ends_with?: Maybe<String>;
  tel?: Maybe<String>;
  tel_not?: Maybe<String>;
  tel_in?: Maybe<String[] | String>;
  tel_not_in?: Maybe<String[] | String>;
  tel_lt?: Maybe<String>;
  tel_lte?: Maybe<String>;
  tel_gt?: Maybe<String>;
  tel_gte?: Maybe<String>;
  tel_contains?: Maybe<String>;
  tel_not_contains?: Maybe<String>;
  tel_starts_with?: Maybe<String>;
  tel_not_starts_with?: Maybe<String>;
  tel_ends_with?: Maybe<String>;
  tel_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  publications?: Maybe<String>;
  publications_not?: Maybe<String>;
  publications_in?: Maybe<String[] | String>;
  publications_not_in?: Maybe<String[] | String>;
  publications_lt?: Maybe<String>;
  publications_lte?: Maybe<String>;
  publications_gt?: Maybe<String>;
  publications_gte?: Maybe<String>;
  publications_contains?: Maybe<String>;
  publications_not_contains?: Maybe<String>;
  publications_starts_with?: Maybe<String>;
  publications_not_starts_with?: Maybe<String>;
  publications_ends_with?: Maybe<String>;
  publications_not_ends_with?: Maybe<String>;
  translation_every?: Maybe<ExpertTranslationWhereInput>;
  translation_some?: Maybe<ExpertTranslationWhereInput>;
  translation_none?: Maybe<ExpertTranslationWhereInput>;
  oecds_every?: Maybe<OecdWhereInput>;
  oecds_some?: Maybe<OecdWhereInput>;
  oecds_none?: Maybe<OecdWhereInput>;
  languages_every?: Maybe<LanguageWhereInput>;
  languages_some?: Maybe<LanguageWhereInput>;
  languages_none?: Maybe<LanguageWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<ExpertWhereInput[] | ExpertWhereInput>;
  OR?: Maybe<ExpertWhereInput[] | ExpertWhereInput>;
  NOT?: Maybe<ExpertWhereInput[] | ExpertWhereInput>;
}

export type ExpertTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type JournalWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  pubNumber?: Maybe<String>;
}>;

export interface QrjTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<QrjTranslationWhereInput[] | QrjTranslationWhereInput>;
  OR?: Maybe<QrjTranslationWhereInput[] | QrjTranslationWhereInput>;
  NOT?: Maybe<QrjTranslationWhereInput[] | QrjTranslationWhereInput>;
}

export interface JournalWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pubNumber?: Maybe<String>;
  pubNumber_not?: Maybe<String>;
  pubNumber_in?: Maybe<String[] | String>;
  pubNumber_not_in?: Maybe<String[] | String>;
  pubNumber_lt?: Maybe<String>;
  pubNumber_lte?: Maybe<String>;
  pubNumber_gt?: Maybe<String>;
  pubNumber_gte?: Maybe<String>;
  pubNumber_contains?: Maybe<String>;
  pubNumber_not_contains?: Maybe<String>;
  pubNumber_starts_with?: Maybe<String>;
  pubNumber_not_starts_with?: Maybe<String>;
  pubNumber_ends_with?: Maybe<String>;
  pubNumber_not_ends_with?: Maybe<String>;
  translation_every?: Maybe<QrjTranslationWhereInput>;
  translation_some?: Maybe<QrjTranslationWhereInput>;
  translation_none?: Maybe<QrjTranslationWhereInput>;
  AND?: Maybe<JournalWhereInput[] | JournalWhereInput>;
  OR?: Maybe<JournalWhereInput[] | JournalWhereInput>;
  NOT?: Maybe<JournalWhereInput[] | JournalWhereInput>;
}

export type KeywordWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface KeywordWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<KeywordWhereInput[] | KeywordWhereInput>;
  OR?: Maybe<KeywordWhereInput[] | KeywordWhereInput>;
  NOT?: Maybe<KeywordWhereInput[] | KeywordWhereInput>;
}

export type LanguageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<LanguageCode>;
  name?: Maybe<String>;
}>;

export type NewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NewsTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type OecdWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export type OecdTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QrjWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  year?: Maybe<String>;
}>;

export interface QrjWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  year?: Maybe<String>;
  year_not?: Maybe<String>;
  year_in?: Maybe<String[] | String>;
  year_not_in?: Maybe<String[] | String>;
  year_lt?: Maybe<String>;
  year_lte?: Maybe<String>;
  year_gt?: Maybe<String>;
  year_gte?: Maybe<String>;
  year_contains?: Maybe<String>;
  year_not_contains?: Maybe<String>;
  year_starts_with?: Maybe<String>;
  year_not_starts_with?: Maybe<String>;
  year_ends_with?: Maybe<String>;
  year_not_ends_with?: Maybe<String>;
  journal_every?: Maybe<JournalWhereInput>;
  journal_some?: Maybe<JournalWhereInput>;
  journal_none?: Maybe<JournalWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<QrjWhereInput[] | QrjWhereInput>;
  OR?: Maybe<QrjWhereInput[] | QrjWhereInput>;
  NOT?: Maybe<QrjWhereInput[] | QrjWhereInput>;
}

export type QrjJournalWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface QrjJournalTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    QrjJournalTranslationWhereInput[] | QrjJournalTranslationWhereInput
  >;
  OR?: Maybe<
    QrjJournalTranslationWhereInput[] | QrjJournalTranslationWhereInput
  >;
  NOT?: Maybe<
    QrjJournalTranslationWhereInput[] | QrjJournalTranslationWhereInput
  >;
}

export interface QrjJournalWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  translation_every?: Maybe<QrjJournalTranslationWhereInput>;
  translation_some?: Maybe<QrjJournalTranslationWhereInput>;
  translation_none?: Maybe<QrjJournalTranslationWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<QrjJournalWhereInput[] | QrjJournalWhereInput>;
  OR?: Maybe<QrjJournalWhereInput[] | QrjJournalWhereInput>;
  NOT?: Maybe<QrjJournalWhereInput[] | QrjJournalWhereInput>;
}

export type QrjJournalTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QrjPublicationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  index?: Maybe<String>;
}>;

export interface QrjPublicationTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationAuthor_not?: Maybe<String>;
  publicationAuthor_in?: Maybe<String[] | String>;
  publicationAuthor_not_in?: Maybe<String[] | String>;
  publicationAuthor_lt?: Maybe<String>;
  publicationAuthor_lte?: Maybe<String>;
  publicationAuthor_gt?: Maybe<String>;
  publicationAuthor_gte?: Maybe<String>;
  publicationAuthor_contains?: Maybe<String>;
  publicationAuthor_not_contains?: Maybe<String>;
  publicationAuthor_starts_with?: Maybe<String>;
  publicationAuthor_not_starts_with?: Maybe<String>;
  publicationAuthor_ends_with?: Maybe<String>;
  publicationAuthor_not_ends_with?: Maybe<String>;
  publicationLang?: Maybe<String>;
  publicationLang_not?: Maybe<String>;
  publicationLang_in?: Maybe<String[] | String>;
  publicationLang_not_in?: Maybe<String[] | String>;
  publicationLang_lt?: Maybe<String>;
  publicationLang_lte?: Maybe<String>;
  publicationLang_gt?: Maybe<String>;
  publicationLang_gte?: Maybe<String>;
  publicationLang_contains?: Maybe<String>;
  publicationLang_not_contains?: Maybe<String>;
  publicationLang_starts_with?: Maybe<String>;
  publicationLang_not_starts_with?: Maybe<String>;
  publicationLang_ends_with?: Maybe<String>;
  publicationLang_not_ends_with?: Maybe<String>;
  abstract?: Maybe<String>;
  abstract_not?: Maybe<String>;
  abstract_in?: Maybe<String[] | String>;
  abstract_not_in?: Maybe<String[] | String>;
  abstract_lt?: Maybe<String>;
  abstract_lte?: Maybe<String>;
  abstract_gt?: Maybe<String>;
  abstract_gte?: Maybe<String>;
  abstract_contains?: Maybe<String>;
  abstract_not_contains?: Maybe<String>;
  abstract_starts_with?: Maybe<String>;
  abstract_not_starts_with?: Maybe<String>;
  abstract_ends_with?: Maybe<String>;
  abstract_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    QrjPublicationTranslationWhereInput[] | QrjPublicationTranslationWhereInput
  >;
  OR?: Maybe<
    QrjPublicationTranslationWhereInput[] | QrjPublicationTranslationWhereInput
  >;
  NOT?: Maybe<
    QrjPublicationTranslationWhereInput[] | QrjPublicationTranslationWhereInput
  >;
}

export interface QrjPublicationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  index?: Maybe<String>;
  index_not?: Maybe<String>;
  index_in?: Maybe<String[] | String>;
  index_not_in?: Maybe<String[] | String>;
  index_lt?: Maybe<String>;
  index_lte?: Maybe<String>;
  index_gt?: Maybe<String>;
  index_gte?: Maybe<String>;
  index_contains?: Maybe<String>;
  index_not_contains?: Maybe<String>;
  index_starts_with?: Maybe<String>;
  index_not_starts_with?: Maybe<String>;
  index_ends_with?: Maybe<String>;
  index_not_ends_with?: Maybe<String>;
  edited?: Maybe<Boolean>;
  edited_not?: Maybe<Boolean>;
  year?: Maybe<String>;
  year_not?: Maybe<String>;
  year_in?: Maybe<String[] | String>;
  year_not_in?: Maybe<String[] | String>;
  year_lt?: Maybe<String>;
  year_lte?: Maybe<String>;
  year_gt?: Maybe<String>;
  year_gte?: Maybe<String>;
  year_contains?: Maybe<String>;
  year_not_contains?: Maybe<String>;
  year_starts_with?: Maybe<String>;
  year_not_starts_with?: Maybe<String>;
  year_ends_with?: Maybe<String>;
  year_not_ends_with?: Maybe<String>;
  number?: Maybe<String>;
  number_not?: Maybe<String>;
  number_in?: Maybe<String[] | String>;
  number_not_in?: Maybe<String[] | String>;
  number_lt?: Maybe<String>;
  number_lte?: Maybe<String>;
  number_gt?: Maybe<String>;
  number_gte?: Maybe<String>;
  number_contains?: Maybe<String>;
  number_not_contains?: Maybe<String>;
  number_starts_with?: Maybe<String>;
  number_not_starts_with?: Maybe<String>;
  number_ends_with?: Maybe<String>;
  number_not_ends_with?: Maybe<String>;
  pages?: Maybe<String>;
  pages_not?: Maybe<String>;
  pages_in?: Maybe<String[] | String>;
  pages_not_in?: Maybe<String[] | String>;
  pages_lt?: Maybe<String>;
  pages_lte?: Maybe<String>;
  pages_gt?: Maybe<String>;
  pages_gte?: Maybe<String>;
  pages_contains?: Maybe<String>;
  pages_not_contains?: Maybe<String>;
  pages_starts_with?: Maybe<String>;
  pages_not_starts_with?: Maybe<String>;
  pages_ends_with?: Maybe<String>;
  pages_not_ends_with?: Maybe<String>;
  doiUrl?: Maybe<String>;
  doiUrl_not?: Maybe<String>;
  doiUrl_in?: Maybe<String[] | String>;
  doiUrl_not_in?: Maybe<String[] | String>;
  doiUrl_lt?: Maybe<String>;
  doiUrl_lte?: Maybe<String>;
  doiUrl_gt?: Maybe<String>;
  doiUrl_gte?: Maybe<String>;
  doiUrl_contains?: Maybe<String>;
  doiUrl_not_contains?: Maybe<String>;
  doiUrl_starts_with?: Maybe<String>;
  doiUrl_not_starts_with?: Maybe<String>;
  doiUrl_ends_with?: Maybe<String>;
  doiUrl_not_ends_with?: Maybe<String>;
  journal?: Maybe<QrjJournalWhereInput>;
  inputDate?: Maybe<DateTimeInput>;
  inputDate_not?: Maybe<DateTimeInput>;
  inputDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  inputDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  inputDate_lt?: Maybe<DateTimeInput>;
  inputDate_lte?: Maybe<DateTimeInput>;
  inputDate_gt?: Maybe<DateTimeInput>;
  inputDate_gte?: Maybe<DateTimeInput>;
  oecd?: Maybe<OecdWhereInput>;
  translation_every?: Maybe<QrjPublicationTranslationWhereInput>;
  translation_some?: Maybe<QrjPublicationTranslationWhereInput>;
  translation_none?: Maybe<QrjPublicationTranslationWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<QrjPublicationWhereInput[] | QrjPublicationWhereInput>;
  OR?: Maybe<QrjPublicationWhereInput[] | QrjPublicationWhereInput>;
  NOT?: Maybe<QrjPublicationWhereInput[] | QrjPublicationWhereInput>;
}

export type QrjPublicationTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QrjTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ResearchProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ResearchProjectTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  key_every?: Maybe<KeywordWhereInput>;
  key_some?: Maybe<KeywordWhereInput>;
  key_none?: Maybe<KeywordWhereInput>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    | ResearchProjectTranslationWhereInput[]
    | ResearchProjectTranslationWhereInput
  >;
  OR?: Maybe<
    | ResearchProjectTranslationWhereInput[]
    | ResearchProjectTranslationWhereInput
  >;
  NOT?: Maybe<
    | ResearchProjectTranslationWhereInput[]
    | ResearchProjectTranslationWhereInput
  >;
}

export interface ResearchProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  inpDate?: Maybe<DateTimeInput>;
  inpDate_not?: Maybe<DateTimeInput>;
  inpDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  inpDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  inpDate_lt?: Maybe<DateTimeInput>;
  inpDate_lte?: Maybe<DateTimeInput>;
  inpDate_gt?: Maybe<DateTimeInput>;
  inpDate_gte?: Maybe<DateTimeInput>;
  regDate?: Maybe<DateTimeInput>;
  regDate_not?: Maybe<DateTimeInput>;
  regDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  regDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  regDate_lt?: Maybe<DateTimeInput>;
  regDate_lte?: Maybe<DateTimeInput>;
  regDate_gt?: Maybe<DateTimeInput>;
  regDate_gte?: Maybe<DateTimeInput>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  regNumb?: Maybe<String>;
  regNumb_not?: Maybe<String>;
  regNumb_in?: Maybe<String[] | String>;
  regNumb_not_in?: Maybe<String[] | String>;
  regNumb_lt?: Maybe<String>;
  regNumb_lte?: Maybe<String>;
  regNumb_gt?: Maybe<String>;
  regNumb_gte?: Maybe<String>;
  regNumb_contains?: Maybe<String>;
  regNumb_not_contains?: Maybe<String>;
  regNumb_starts_with?: Maybe<String>;
  regNumb_not_starts_with?: Maybe<String>;
  regNumb_ends_with?: Maybe<String>;
  regNumb_not_ends_with?: Maybe<String>;
  research?: Maybe<String>;
  research_not?: Maybe<String>;
  research_in?: Maybe<String[] | String>;
  research_not_in?: Maybe<String[] | String>;
  research_lt?: Maybe<String>;
  research_lte?: Maybe<String>;
  research_gt?: Maybe<String>;
  research_gte?: Maybe<String>;
  research_contains?: Maybe<String>;
  research_not_contains?: Maybe<String>;
  research_starts_with?: Maybe<String>;
  research_not_starts_with?: Maybe<String>;
  research_ends_with?: Maybe<String>;
  research_not_ends_with?: Maybe<String>;
  researchDirection?: Maybe<String>;
  researchDirection_not?: Maybe<String>;
  researchDirection_in?: Maybe<String[] | String>;
  researchDirection_not_in?: Maybe<String[] | String>;
  researchDirection_lt?: Maybe<String>;
  researchDirection_lte?: Maybe<String>;
  researchDirection_gt?: Maybe<String>;
  researchDirection_gte?: Maybe<String>;
  researchDirection_contains?: Maybe<String>;
  researchDirection_not_contains?: Maybe<String>;
  researchDirection_starts_with?: Maybe<String>;
  researchDirection_not_starts_with?: Maybe<String>;
  researchDirection_ends_with?: Maybe<String>;
  researchDirection_not_ends_with?: Maybe<String>;
  researchExecutionBasis?: Maybe<String>;
  researchExecutionBasis_not?: Maybe<String>;
  researchExecutionBasis_in?: Maybe<String[] | String>;
  researchExecutionBasis_not_in?: Maybe<String[] | String>;
  researchExecutionBasis_lt?: Maybe<String>;
  researchExecutionBasis_lte?: Maybe<String>;
  researchExecutionBasis_gt?: Maybe<String>;
  researchExecutionBasis_gte?: Maybe<String>;
  researchExecutionBasis_contains?: Maybe<String>;
  researchExecutionBasis_not_contains?: Maybe<String>;
  researchExecutionBasis_starts_with?: Maybe<String>;
  researchExecutionBasis_not_starts_with?: Maybe<String>;
  researchExecutionBasis_ends_with?: Maybe<String>;
  researchExecutionBasis_not_ends_with?: Maybe<String>;
  abstract?: Maybe<String>;
  abstract_not?: Maybe<String>;
  abstract_in?: Maybe<String[] | String>;
  abstract_not_in?: Maybe<String[] | String>;
  abstract_lt?: Maybe<String>;
  abstract_lte?: Maybe<String>;
  abstract_gt?: Maybe<String>;
  abstract_gte?: Maybe<String>;
  abstract_contains?: Maybe<String>;
  abstract_not_contains?: Maybe<String>;
  abstract_starts_with?: Maybe<String>;
  abstract_not_starts_with?: Maybe<String>;
  abstract_ends_with?: Maybe<String>;
  abstract_not_ends_with?: Maybe<String>;
  annotation?: Maybe<String>;
  annotation_not?: Maybe<String>;
  annotation_in?: Maybe<String[] | String>;
  annotation_not_in?: Maybe<String[] | String>;
  annotation_lt?: Maybe<String>;
  annotation_lte?: Maybe<String>;
  annotation_gt?: Maybe<String>;
  annotation_gte?: Maybe<String>;
  annotation_contains?: Maybe<String>;
  annotation_not_contains?: Maybe<String>;
  annotation_starts_with?: Maybe<String>;
  annotation_not_starts_with?: Maybe<String>;
  annotation_ends_with?: Maybe<String>;
  annotation_not_ends_with?: Maybe<String>;
  budget?: Maybe<Int>;
  budget_not?: Maybe<Int>;
  budget_in?: Maybe<Int[] | Int>;
  budget_not_in?: Maybe<Int[] | Int>;
  budget_lt?: Maybe<Int>;
  budget_lte?: Maybe<Int>;
  budget_gt?: Maybe<Int>;
  budget_gte?: Maybe<Int>;
  organizationName?: Maybe<String>;
  organizationName_not?: Maybe<String>;
  organizationName_in?: Maybe<String[] | String>;
  organizationName_not_in?: Maybe<String[] | String>;
  organizationName_lt?: Maybe<String>;
  organizationName_lte?: Maybe<String>;
  organizationName_gt?: Maybe<String>;
  organizationName_gte?: Maybe<String>;
  organizationName_contains?: Maybe<String>;
  organizationName_not_contains?: Maybe<String>;
  organizationName_starts_with?: Maybe<String>;
  organizationName_not_starts_with?: Maybe<String>;
  organizationName_ends_with?: Maybe<String>;
  organizationName_not_ends_with?: Maybe<String>;
  organizationShortName?: Maybe<String>;
  organizationShortName_not?: Maybe<String>;
  organizationShortName_in?: Maybe<String[] | String>;
  organizationShortName_not_in?: Maybe<String[] | String>;
  organizationShortName_lt?: Maybe<String>;
  organizationShortName_lte?: Maybe<String>;
  organizationShortName_gt?: Maybe<String>;
  organizationShortName_gte?: Maybe<String>;
  organizationShortName_contains?: Maybe<String>;
  organizationShortName_not_contains?: Maybe<String>;
  organizationShortName_starts_with?: Maybe<String>;
  organizationShortName_not_starts_with?: Maybe<String>;
  organizationShortName_ends_with?: Maybe<String>;
  organizationShortName_not_ends_with?: Maybe<String>;
  organizationCode?: Maybe<String>;
  organizationCode_not?: Maybe<String>;
  organizationCode_in?: Maybe<String[] | String>;
  organizationCode_not_in?: Maybe<String[] | String>;
  organizationCode_lt?: Maybe<String>;
  organizationCode_lte?: Maybe<String>;
  organizationCode_gt?: Maybe<String>;
  organizationCode_gte?: Maybe<String>;
  organizationCode_contains?: Maybe<String>;
  organizationCode_not_contains?: Maybe<String>;
  organizationCode_starts_with?: Maybe<String>;
  organizationCode_not_starts_with?: Maybe<String>;
  organizationCode_ends_with?: Maybe<String>;
  organizationCode_not_ends_with?: Maybe<String>;
  organizationHead?: Maybe<String>;
  organizationHead_not?: Maybe<String>;
  organizationHead_in?: Maybe<String[] | String>;
  organizationHead_not_in?: Maybe<String[] | String>;
  organizationHead_lt?: Maybe<String>;
  organizationHead_lte?: Maybe<String>;
  organizationHead_gt?: Maybe<String>;
  organizationHead_gte?: Maybe<String>;
  organizationHead_contains?: Maybe<String>;
  organizationHead_not_contains?: Maybe<String>;
  organizationHead_starts_with?: Maybe<String>;
  organizationHead_not_starts_with?: Maybe<String>;
  organizationHead_ends_with?: Maybe<String>;
  organizationHead_not_ends_with?: Maybe<String>;
  organizationCity?: Maybe<String>;
  organizationCity_not?: Maybe<String>;
  organizationCity_in?: Maybe<String[] | String>;
  organizationCity_not_in?: Maybe<String[] | String>;
  organizationCity_lt?: Maybe<String>;
  organizationCity_lte?: Maybe<String>;
  organizationCity_gt?: Maybe<String>;
  organizationCity_gte?: Maybe<String>;
  organizationCity_contains?: Maybe<String>;
  organizationCity_not_contains?: Maybe<String>;
  organizationCity_starts_with?: Maybe<String>;
  organizationCity_not_starts_with?: Maybe<String>;
  organizationCity_ends_with?: Maybe<String>;
  organizationCity_not_ends_with?: Maybe<String>;
  organizationAddress?: Maybe<String>;
  organizationAddress_not?: Maybe<String>;
  organizationAddress_in?: Maybe<String[] | String>;
  organizationAddress_not_in?: Maybe<String[] | String>;
  organizationAddress_lt?: Maybe<String>;
  organizationAddress_lte?: Maybe<String>;
  organizationAddress_gt?: Maybe<String>;
  organizationAddress_gte?: Maybe<String>;
  organizationAddress_contains?: Maybe<String>;
  organizationAddress_not_contains?: Maybe<String>;
  organizationAddress_starts_with?: Maybe<String>;
  organizationAddress_not_starts_with?: Maybe<String>;
  organizationAddress_ends_with?: Maybe<String>;
  organizationAddress_not_ends_with?: Maybe<String>;
  organizationIndex?: Maybe<String>;
  organizationIndex_not?: Maybe<String>;
  organizationIndex_in?: Maybe<String[] | String>;
  organizationIndex_not_in?: Maybe<String[] | String>;
  organizationIndex_lt?: Maybe<String>;
  organizationIndex_lte?: Maybe<String>;
  organizationIndex_gt?: Maybe<String>;
  organizationIndex_gte?: Maybe<String>;
  organizationIndex_contains?: Maybe<String>;
  organizationIndex_not_contains?: Maybe<String>;
  organizationIndex_starts_with?: Maybe<String>;
  organizationIndex_not_starts_with?: Maybe<String>;
  organizationIndex_ends_with?: Maybe<String>;
  organizationIndex_not_ends_with?: Maybe<String>;
  organizationTel?: Maybe<String>;
  organizationTel_not?: Maybe<String>;
  organizationTel_in?: Maybe<String[] | String>;
  organizationTel_not_in?: Maybe<String[] | String>;
  organizationTel_lt?: Maybe<String>;
  organizationTel_lte?: Maybe<String>;
  organizationTel_gt?: Maybe<String>;
  organizationTel_gte?: Maybe<String>;
  organizationTel_contains?: Maybe<String>;
  organizationTel_not_contains?: Maybe<String>;
  organizationTel_starts_with?: Maybe<String>;
  organizationTel_not_starts_with?: Maybe<String>;
  organizationTel_ends_with?: Maybe<String>;
  organizationTel_not_ends_with?: Maybe<String>;
  organizationWeb?: Maybe<String>;
  organizationWeb_not?: Maybe<String>;
  organizationWeb_in?: Maybe<String[] | String>;
  organizationWeb_not_in?: Maybe<String[] | String>;
  organizationWeb_lt?: Maybe<String>;
  organizationWeb_lte?: Maybe<String>;
  organizationWeb_gt?: Maybe<String>;
  organizationWeb_gte?: Maybe<String>;
  organizationWeb_contains?: Maybe<String>;
  organizationWeb_not_contains?: Maybe<String>;
  organizationWeb_starts_with?: Maybe<String>;
  organizationWeb_not_starts_with?: Maybe<String>;
  organizationWeb_ends_with?: Maybe<String>;
  organizationWeb_not_ends_with?: Maybe<String>;
  participatingInstitutionName?: Maybe<String>;
  participatingInstitutionName_not?: Maybe<String>;
  participatingInstitutionName_in?: Maybe<String[] | String>;
  participatingInstitutionName_not_in?: Maybe<String[] | String>;
  participatingInstitutionName_lt?: Maybe<String>;
  participatingInstitutionName_lte?: Maybe<String>;
  participatingInstitutionName_gt?: Maybe<String>;
  participatingInstitutionName_gte?: Maybe<String>;
  participatingInstitutionName_contains?: Maybe<String>;
  participatingInstitutionName_not_contains?: Maybe<String>;
  participatingInstitutionName_starts_with?: Maybe<String>;
  participatingInstitutionName_not_starts_with?: Maybe<String>;
  participatingInstitutionName_ends_with?: Maybe<String>;
  participatingInstitutionName_not_ends_with?: Maybe<String>;
  participatingInstitutionCountryCity?: Maybe<String>;
  participatingInstitutionCountryCity_not?: Maybe<String>;
  participatingInstitutionCountryCity_in?: Maybe<String[] | String>;
  participatingInstitutionCountryCity_not_in?: Maybe<String[] | String>;
  participatingInstitutionCountryCity_lt?: Maybe<String>;
  participatingInstitutionCountryCity_lte?: Maybe<String>;
  participatingInstitutionCountryCity_gt?: Maybe<String>;
  participatingInstitutionCountryCity_gte?: Maybe<String>;
  participatingInstitutionCountryCity_contains?: Maybe<String>;
  participatingInstitutionCountryCity_not_contains?: Maybe<String>;
  participatingInstitutionCountryCity_starts_with?: Maybe<String>;
  participatingInstitutionCountryCity_not_starts_with?: Maybe<String>;
  participatingInstitutionCountryCity_ends_with?: Maybe<String>;
  participatingInstitutionCountryCity_not_ends_with?: Maybe<String>;
  participatingInstitutionTel?: Maybe<String>;
  participatingInstitutionTel_not?: Maybe<String>;
  participatingInstitutionTel_in?: Maybe<String[] | String>;
  participatingInstitutionTel_not_in?: Maybe<String[] | String>;
  participatingInstitutionTel_lt?: Maybe<String>;
  participatingInstitutionTel_lte?: Maybe<String>;
  participatingInstitutionTel_gt?: Maybe<String>;
  participatingInstitutionTel_gte?: Maybe<String>;
  participatingInstitutionTel_contains?: Maybe<String>;
  participatingInstitutionTel_not_contains?: Maybe<String>;
  participatingInstitutionTel_starts_with?: Maybe<String>;
  participatingInstitutionTel_not_starts_with?: Maybe<String>;
  participatingInstitutionTel_ends_with?: Maybe<String>;
  participatingInstitutionTel_not_ends_with?: Maybe<String>;
  participatingInstitutionEmail?: Maybe<String>;
  participatingInstitutionEmail_not?: Maybe<String>;
  participatingInstitutionEmail_in?: Maybe<String[] | String>;
  participatingInstitutionEmail_not_in?: Maybe<String[] | String>;
  participatingInstitutionEmail_lt?: Maybe<String>;
  participatingInstitutionEmail_lte?: Maybe<String>;
  participatingInstitutionEmail_gt?: Maybe<String>;
  participatingInstitutionEmail_gte?: Maybe<String>;
  participatingInstitutionEmail_contains?: Maybe<String>;
  participatingInstitutionEmail_not_contains?: Maybe<String>;
  participatingInstitutionEmail_starts_with?: Maybe<String>;
  participatingInstitutionEmail_not_starts_with?: Maybe<String>;
  participatingInstitutionEmail_ends_with?: Maybe<String>;
  participatingInstitutionEmail_not_ends_with?: Maybe<String>;
  participatingInstitutionWeb?: Maybe<String>;
  participatingInstitutionWeb_not?: Maybe<String>;
  participatingInstitutionWeb_in?: Maybe<String[] | String>;
  participatingInstitutionWeb_not_in?: Maybe<String[] | String>;
  participatingInstitutionWeb_lt?: Maybe<String>;
  participatingInstitutionWeb_lte?: Maybe<String>;
  participatingInstitutionWeb_gt?: Maybe<String>;
  participatingInstitutionWeb_gte?: Maybe<String>;
  participatingInstitutionWeb_contains?: Maybe<String>;
  participatingInstitutionWeb_not_contains?: Maybe<String>;
  participatingInstitutionWeb_starts_with?: Maybe<String>;
  participatingInstitutionWeb_not_starts_with?: Maybe<String>;
  participatingInstitutionWeb_ends_with?: Maybe<String>;
  participatingInstitutionWeb_not_ends_with?: Maybe<String>;
  leaderName?: Maybe<String>;
  leaderName_not?: Maybe<String>;
  leaderName_in?: Maybe<String[] | String>;
  leaderName_not_in?: Maybe<String[] | String>;
  leaderName_lt?: Maybe<String>;
  leaderName_lte?: Maybe<String>;
  leaderName_gt?: Maybe<String>;
  leaderName_gte?: Maybe<String>;
  leaderName_contains?: Maybe<String>;
  leaderName_not_contains?: Maybe<String>;
  leaderName_starts_with?: Maybe<String>;
  leaderName_not_starts_with?: Maybe<String>;
  leaderName_ends_with?: Maybe<String>;
  leaderName_not_ends_with?: Maybe<String>;
  leaderPosition?: Maybe<String>;
  leaderPosition_not?: Maybe<String>;
  leaderPosition_in?: Maybe<String[] | String>;
  leaderPosition_not_in?: Maybe<String[] | String>;
  leaderPosition_lt?: Maybe<String>;
  leaderPosition_lte?: Maybe<String>;
  leaderPosition_gt?: Maybe<String>;
  leaderPosition_gte?: Maybe<String>;
  leaderPosition_contains?: Maybe<String>;
  leaderPosition_not_contains?: Maybe<String>;
  leaderPosition_starts_with?: Maybe<String>;
  leaderPosition_not_starts_with?: Maybe<String>;
  leaderPosition_ends_with?: Maybe<String>;
  leaderPosition_not_ends_with?: Maybe<String>;
  leaderAcademicDegree?: Maybe<String>;
  leaderAcademicDegree_not?: Maybe<String>;
  leaderAcademicDegree_in?: Maybe<String[] | String>;
  leaderAcademicDegree_not_in?: Maybe<String[] | String>;
  leaderAcademicDegree_lt?: Maybe<String>;
  leaderAcademicDegree_lte?: Maybe<String>;
  leaderAcademicDegree_gt?: Maybe<String>;
  leaderAcademicDegree_gte?: Maybe<String>;
  leaderAcademicDegree_contains?: Maybe<String>;
  leaderAcademicDegree_not_contains?: Maybe<String>;
  leaderAcademicDegree_starts_with?: Maybe<String>;
  leaderAcademicDegree_not_starts_with?: Maybe<String>;
  leaderAcademicDegree_ends_with?: Maybe<String>;
  leaderAcademicDegree_not_ends_with?: Maybe<String>;
  leaderTel?: Maybe<String>;
  leaderTel_not?: Maybe<String>;
  leaderTel_in?: Maybe<String[] | String>;
  leaderTel_not_in?: Maybe<String[] | String>;
  leaderTel_lt?: Maybe<String>;
  leaderTel_lte?: Maybe<String>;
  leaderTel_gt?: Maybe<String>;
  leaderTel_gte?: Maybe<String>;
  leaderTel_contains?: Maybe<String>;
  leaderTel_not_contains?: Maybe<String>;
  leaderTel_starts_with?: Maybe<String>;
  leaderTel_not_starts_with?: Maybe<String>;
  leaderTel_ends_with?: Maybe<String>;
  leaderTel_not_ends_with?: Maybe<String>;
  leaderMobile?: Maybe<String>;
  leaderMobile_not?: Maybe<String>;
  leaderMobile_in?: Maybe<String[] | String>;
  leaderMobile_not_in?: Maybe<String[] | String>;
  leaderMobile_lt?: Maybe<String>;
  leaderMobile_lte?: Maybe<String>;
  leaderMobile_gt?: Maybe<String>;
  leaderMobile_gte?: Maybe<String>;
  leaderMobile_contains?: Maybe<String>;
  leaderMobile_not_contains?: Maybe<String>;
  leaderMobile_starts_with?: Maybe<String>;
  leaderMobile_not_starts_with?: Maybe<String>;
  leaderMobile_ends_with?: Maybe<String>;
  leaderMobile_not_ends_with?: Maybe<String>;
  leaderEmail?: Maybe<String>;
  leaderEmail_not?: Maybe<String>;
  leaderEmail_in?: Maybe<String[] | String>;
  leaderEmail_not_in?: Maybe<String[] | String>;
  leaderEmail_lt?: Maybe<String>;
  leaderEmail_lte?: Maybe<String>;
  leaderEmail_gt?: Maybe<String>;
  leaderEmail_gte?: Maybe<String>;
  leaderEmail_contains?: Maybe<String>;
  leaderEmail_not_contains?: Maybe<String>;
  leaderEmail_starts_with?: Maybe<String>;
  leaderEmail_not_starts_with?: Maybe<String>;
  leaderEmail_ends_with?: Maybe<String>;
  leaderEmail_not_ends_with?: Maybe<String>;
  researchExecutors?: Maybe<String>;
  researchExecutors_not?: Maybe<String>;
  researchExecutors_in?: Maybe<String[] | String>;
  researchExecutors_not_in?: Maybe<String[] | String>;
  researchExecutors_lt?: Maybe<String>;
  researchExecutors_lte?: Maybe<String>;
  researchExecutors_gt?: Maybe<String>;
  researchExecutors_gte?: Maybe<String>;
  researchExecutors_contains?: Maybe<String>;
  researchExecutors_not_contains?: Maybe<String>;
  researchExecutors_starts_with?: Maybe<String>;
  researchExecutors_not_starts_with?: Maybe<String>;
  researchExecutors_ends_with?: Maybe<String>;
  researchExecutors_not_ends_with?: Maybe<String>;
  financing?: Maybe<String>;
  financing_not?: Maybe<String>;
  financing_in?: Maybe<String[] | String>;
  financing_not_in?: Maybe<String[] | String>;
  financing_lt?: Maybe<String>;
  financing_lte?: Maybe<String>;
  financing_gt?: Maybe<String>;
  financing_gte?: Maybe<String>;
  financing_contains?: Maybe<String>;
  financing_not_contains?: Maybe<String>;
  financing_starts_with?: Maybe<String>;
  financing_not_starts_with?: Maybe<String>;
  financing_ends_with?: Maybe<String>;
  financing_not_ends_with?: Maybe<String>;
  note?: Maybe<String>;
  note_not?: Maybe<String>;
  note_in?: Maybe<String[] | String>;
  note_not_in?: Maybe<String[] | String>;
  note_lt?: Maybe<String>;
  note_lte?: Maybe<String>;
  note_gt?: Maybe<String>;
  note_gte?: Maybe<String>;
  note_contains?: Maybe<String>;
  note_not_contains?: Maybe<String>;
  note_starts_with?: Maybe<String>;
  note_not_starts_with?: Maybe<String>;
  note_ends_with?: Maybe<String>;
  note_not_ends_with?: Maybe<String>;
  pincode?: Maybe<String>;
  pincode_not?: Maybe<String>;
  pincode_in?: Maybe<String[] | String>;
  pincode_not_in?: Maybe<String[] | String>;
  pincode_lt?: Maybe<String>;
  pincode_lte?: Maybe<String>;
  pincode_gt?: Maybe<String>;
  pincode_gte?: Maybe<String>;
  pincode_contains?: Maybe<String>;
  pincode_not_contains?: Maybe<String>;
  pincode_starts_with?: Maybe<String>;
  pincode_not_starts_with?: Maybe<String>;
  pincode_ends_with?: Maybe<String>;
  pincode_not_ends_with?: Maybe<String>;
  translation_every?: Maybe<ResearchProjectTranslationWhereInput>;
  translation_some?: Maybe<ResearchProjectTranslationWhereInput>;
  translation_none?: Maybe<ResearchProjectTranslationWhereInput>;
  oecds_every?: Maybe<OecdWhereInput>;
  oecds_some?: Maybe<OecdWhereInput>;
  oecds_none?: Maybe<OecdWhereInput>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<ResearchProjectWhereInput[] | ResearchProjectWhereInput>;
  OR?: Maybe<ResearchProjectWhereInput[] | ResearchProjectWhereInput>;
  NOT?: Maybe<ResearchProjectWhereInput[] | ResearchProjectWhereInput>;
}

export type ResearchProjectTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TechnologyTransferAndInnovationOrganizationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TechnologyTransferAndInnovationOrganizationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  region?: Maybe<String>;
  region_not?: Maybe<String>;
  region_in?: Maybe<String[] | String>;
  region_not_in?: Maybe<String[] | String>;
  region_lt?: Maybe<String>;
  region_lte?: Maybe<String>;
  region_gt?: Maybe<String>;
  region_gte?: Maybe<String>;
  region_contains?: Maybe<String>;
  region_not_contains?: Maybe<String>;
  region_starts_with?: Maybe<String>;
  region_not_starts_with?: Maybe<String>;
  region_ends_with?: Maybe<String>;
  region_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<
    | TechnologyTransferAndInnovationOrganizationWhereInput[]
    | TechnologyTransferAndInnovationOrganizationWhereInput
  >;
  OR?: Maybe<
    | TechnologyTransferAndInnovationOrganizationWhereInput[]
    | TechnologyTransferAndInnovationOrganizationWhereInput
  >;
  NOT?: Maybe<
    | TechnologyTransferAndInnovationOrganizationWhereInput[]
    | TechnologyTransferAndInnovationOrganizationWhereInput
  >;
}

export type TechnologyTransferNetworkWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TechnologyTransferNetworkWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  region?: Maybe<String>;
  region_not?: Maybe<String>;
  region_in?: Maybe<String[] | String>;
  region_not_in?: Maybe<String[] | String>;
  region_lt?: Maybe<String>;
  region_lte?: Maybe<String>;
  region_gt?: Maybe<String>;
  region_gte?: Maybe<String>;
  region_contains?: Maybe<String>;
  region_not_contains?: Maybe<String>;
  region_starts_with?: Maybe<String>;
  region_not_starts_with?: Maybe<String>;
  region_ends_with?: Maybe<String>;
  region_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<
    TechnologyTransferNetworkWhereInput[] | TechnologyTransferNetworkWhereInput
  >;
  OR?: Maybe<
    TechnologyTransferNetworkWhereInput[] | TechnologyTransferNetworkWhereInput
  >;
  NOT?: Maybe<
    TechnologyTransferNetworkWhereInput[] | TechnologyTransferNetworkWhereInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type UserTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DepartmentCreateInput {
  id?: Maybe<ID_Input>;
  translation?: Maybe<DepartmentTranslationCreateManyWithoutDepartmentInput>;
}

export interface DepartmentTranslationCreateManyWithoutDepartmentInput {
  create?: Maybe<
    | DepartmentTranslationCreateWithoutDepartmentInput[]
    | DepartmentTranslationCreateWithoutDepartmentInput
  >;
  connect?: Maybe<
    | DepartmentTranslationWhereUniqueInput[]
    | DepartmentTranslationWhereUniqueInput
  >;
}

export interface DepartmentTranslationCreateWithoutDepartmentInput {
  id?: Maybe<ID_Input>;
  name: String;
  language: LanguageCreateOneInput;
}

export interface LanguageCreateOneInput {
  create?: Maybe<LanguageCreateInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface LanguageCreateInput {
  id?: Maybe<ID_Input>;
  code: LanguageCode;
  name: String;
}

export interface DepartmentUpdateInput {
  translation?: Maybe<DepartmentTranslationUpdateManyWithoutDepartmentInput>;
}

export interface DepartmentTranslationUpdateManyWithoutDepartmentInput {
  create?: Maybe<
    | DepartmentTranslationCreateWithoutDepartmentInput[]
    | DepartmentTranslationCreateWithoutDepartmentInput
  >;
  delete?: Maybe<
    | DepartmentTranslationWhereUniqueInput[]
    | DepartmentTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    | DepartmentTranslationWhereUniqueInput[]
    | DepartmentTranslationWhereUniqueInput
  >;
  set?: Maybe<
    | DepartmentTranslationWhereUniqueInput[]
    | DepartmentTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    | DepartmentTranslationWhereUniqueInput[]
    | DepartmentTranslationWhereUniqueInput
  >;
  update?: Maybe<
    | DepartmentTranslationUpdateWithWhereUniqueWithoutDepartmentInput[]
    | DepartmentTranslationUpdateWithWhereUniqueWithoutDepartmentInput
  >;
  upsert?: Maybe<
    | DepartmentTranslationUpsertWithWhereUniqueWithoutDepartmentInput[]
    | DepartmentTranslationUpsertWithWhereUniqueWithoutDepartmentInput
  >;
  deleteMany?: Maybe<
    | DepartmentTranslationScalarWhereInput[]
    | DepartmentTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | DepartmentTranslationUpdateManyWithWhereNestedInput[]
    | DepartmentTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface DepartmentTranslationUpdateWithWhereUniqueWithoutDepartmentInput {
  where: DepartmentTranslationWhereUniqueInput;
  data: DepartmentTranslationUpdateWithoutDepartmentDataInput;
}

export interface DepartmentTranslationUpdateWithoutDepartmentDataInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface LanguageUpdateOneRequiredInput {
  create?: Maybe<LanguageCreateInput>;
  update?: Maybe<LanguageUpdateDataInput>;
  upsert?: Maybe<LanguageUpsertNestedInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface LanguageUpdateDataInput {
  code?: Maybe<LanguageCode>;
  name?: Maybe<String>;
}

export interface LanguageUpsertNestedInput {
  update: LanguageUpdateDataInput;
  create: LanguageCreateInput;
}

export interface DepartmentTranslationUpsertWithWhereUniqueWithoutDepartmentInput {
  where: DepartmentTranslationWhereUniqueInput;
  update: DepartmentTranslationUpdateWithoutDepartmentDataInput;
  create: DepartmentTranslationCreateWithoutDepartmentInput;
}

export interface DepartmentTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | DepartmentTranslationScalarWhereInput[]
    | DepartmentTranslationScalarWhereInput
  >;
  OR?: Maybe<
    | DepartmentTranslationScalarWhereInput[]
    | DepartmentTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    | DepartmentTranslationScalarWhereInput[]
    | DepartmentTranslationScalarWhereInput
  >;
}

export interface DepartmentTranslationUpdateManyWithWhereNestedInput {
  where: DepartmentTranslationScalarWhereInput;
  data: DepartmentTranslationUpdateManyDataInput;
}

export interface DepartmentTranslationUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface DepartmentTranslationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  language: LanguageCreateOneInput;
  department: DepartmentCreateOneWithoutTranslationInput;
}

export interface DepartmentCreateOneWithoutTranslationInput {
  create?: Maybe<DepartmentCreateWithoutTranslationInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentCreateWithoutTranslationInput {
  id?: Maybe<ID_Input>;
}

export interface DepartmentTranslationUpdateInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
  department?: Maybe<DepartmentUpdateOneRequiredWithoutTranslationInput>;
}

export interface DepartmentUpdateOneRequiredWithoutTranslationInput {
  create?: Maybe<DepartmentCreateWithoutTranslationInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentTranslationUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface EmployeeCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  gender: Gender;
  tel: String;
  department: DepartmentCreateOneInput;
  position: EmployeePositionCreateOneInput;
  translation?: Maybe<EmployeeTranslationCreateManyInput>;
}

export interface DepartmentCreateOneInput {
  create?: Maybe<DepartmentCreateInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface EmployeePositionCreateOneInput {
  create?: Maybe<EmployeePositionCreateInput>;
  connect?: Maybe<EmployeePositionWhereUniqueInput>;
}

export interface EmployeePositionCreateInput {
  id?: Maybe<ID_Input>;
  translation?: Maybe<
    EmployeePositionTranslationCreateManyWithoutPositionInput
  >;
}

export interface EmployeePositionTranslationCreateManyWithoutPositionInput {
  create?: Maybe<
    | EmployeePositionTranslationCreateWithoutPositionInput[]
    | EmployeePositionTranslationCreateWithoutPositionInput
  >;
  connect?: Maybe<
    | EmployeePositionTranslationWhereUniqueInput[]
    | EmployeePositionTranslationWhereUniqueInput
  >;
}

export interface EmployeePositionTranslationCreateWithoutPositionInput {
  id?: Maybe<ID_Input>;
  name: String;
  language: LanguageCreateOneInput;
}

export interface EmployeeTranslationCreateManyInput {
  create?: Maybe<
    EmployeeTranslationCreateInput[] | EmployeeTranslationCreateInput
  >;
  connect?: Maybe<
    EmployeeTranslationWhereUniqueInput[] | EmployeeTranslationWhereUniqueInput
  >;
}

export interface EmployeeTranslationCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  language: LanguageCreateOneInput;
}

export interface EmployeeUpdateInput {
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  tel?: Maybe<String>;
  department?: Maybe<DepartmentUpdateOneRequiredInput>;
  position?: Maybe<EmployeePositionUpdateOneRequiredInput>;
  translation?: Maybe<EmployeeTranslationUpdateManyInput>;
}

export interface DepartmentUpdateOneRequiredInput {
  create?: Maybe<DepartmentCreateInput>;
  update?: Maybe<DepartmentUpdateDataInput>;
  upsert?: Maybe<DepartmentUpsertNestedInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface DepartmentUpdateDataInput {
  translation?: Maybe<DepartmentTranslationUpdateManyWithoutDepartmentInput>;
}

export interface DepartmentUpsertNestedInput {
  update: DepartmentUpdateDataInput;
  create: DepartmentCreateInput;
}

export interface EmployeePositionUpdateOneRequiredInput {
  create?: Maybe<EmployeePositionCreateInput>;
  update?: Maybe<EmployeePositionUpdateDataInput>;
  upsert?: Maybe<EmployeePositionUpsertNestedInput>;
  connect?: Maybe<EmployeePositionWhereUniqueInput>;
}

export interface EmployeePositionUpdateDataInput {
  translation?: Maybe<
    EmployeePositionTranslationUpdateManyWithoutPositionInput
  >;
}

export interface EmployeePositionTranslationUpdateManyWithoutPositionInput {
  create?: Maybe<
    | EmployeePositionTranslationCreateWithoutPositionInput[]
    | EmployeePositionTranslationCreateWithoutPositionInput
  >;
  delete?: Maybe<
    | EmployeePositionTranslationWhereUniqueInput[]
    | EmployeePositionTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    | EmployeePositionTranslationWhereUniqueInput[]
    | EmployeePositionTranslationWhereUniqueInput
  >;
  set?: Maybe<
    | EmployeePositionTranslationWhereUniqueInput[]
    | EmployeePositionTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    | EmployeePositionTranslationWhereUniqueInput[]
    | EmployeePositionTranslationWhereUniqueInput
  >;
  update?: Maybe<
    | EmployeePositionTranslationUpdateWithWhereUniqueWithoutPositionInput[]
    | EmployeePositionTranslationUpdateWithWhereUniqueWithoutPositionInput
  >;
  upsert?: Maybe<
    | EmployeePositionTranslationUpsertWithWhereUniqueWithoutPositionInput[]
    | EmployeePositionTranslationUpsertWithWhereUniqueWithoutPositionInput
  >;
  deleteMany?: Maybe<
    | EmployeePositionTranslationScalarWhereInput[]
    | EmployeePositionTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | EmployeePositionTranslationUpdateManyWithWhereNestedInput[]
    | EmployeePositionTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface EmployeePositionTranslationUpdateWithWhereUniqueWithoutPositionInput {
  where: EmployeePositionTranslationWhereUniqueInput;
  data: EmployeePositionTranslationUpdateWithoutPositionDataInput;
}

export interface EmployeePositionTranslationUpdateWithoutPositionDataInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface EmployeePositionTranslationUpsertWithWhereUniqueWithoutPositionInput {
  where: EmployeePositionTranslationWhereUniqueInput;
  update: EmployeePositionTranslationUpdateWithoutPositionDataInput;
  create: EmployeePositionTranslationCreateWithoutPositionInput;
}

export interface EmployeePositionTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | EmployeePositionTranslationScalarWhereInput[]
    | EmployeePositionTranslationScalarWhereInput
  >;
  OR?: Maybe<
    | EmployeePositionTranslationScalarWhereInput[]
    | EmployeePositionTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    | EmployeePositionTranslationScalarWhereInput[]
    | EmployeePositionTranslationScalarWhereInput
  >;
}

export interface EmployeePositionTranslationUpdateManyWithWhereNestedInput {
  where: EmployeePositionTranslationScalarWhereInput;
  data: EmployeePositionTranslationUpdateManyDataInput;
}

export interface EmployeePositionTranslationUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface EmployeePositionUpsertNestedInput {
  update: EmployeePositionUpdateDataInput;
  create: EmployeePositionCreateInput;
}

export interface EmployeeTranslationUpdateManyInput {
  create?: Maybe<
    EmployeeTranslationCreateInput[] | EmployeeTranslationCreateInput
  >;
  update?: Maybe<
    | EmployeeTranslationUpdateWithWhereUniqueNestedInput[]
    | EmployeeTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EmployeeTranslationUpsertWithWhereUniqueNestedInput[]
    | EmployeeTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    EmployeeTranslationWhereUniqueInput[] | EmployeeTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    EmployeeTranslationWhereUniqueInput[] | EmployeeTranslationWhereUniqueInput
  >;
  set?: Maybe<
    EmployeeTranslationWhereUniqueInput[] | EmployeeTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    EmployeeTranslationWhereUniqueInput[] | EmployeeTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    EmployeeTranslationScalarWhereInput[] | EmployeeTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | EmployeeTranslationUpdateManyWithWhereNestedInput[]
    | EmployeeTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface EmployeeTranslationUpdateWithWhereUniqueNestedInput {
  where: EmployeeTranslationWhereUniqueInput;
  data: EmployeeTranslationUpdateDataInput;
}

export interface EmployeeTranslationUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface EmployeeTranslationUpsertWithWhereUniqueNestedInput {
  where: EmployeeTranslationWhereUniqueInput;
  update: EmployeeTranslationUpdateDataInput;
  create: EmployeeTranslationCreateInput;
}

export interface EmployeeTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    EmployeeTranslationScalarWhereInput[] | EmployeeTranslationScalarWhereInput
  >;
  OR?: Maybe<
    EmployeeTranslationScalarWhereInput[] | EmployeeTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    EmployeeTranslationScalarWhereInput[] | EmployeeTranslationScalarWhereInput
  >;
}

export interface EmployeeTranslationUpdateManyWithWhereNestedInput {
  where: EmployeeTranslationScalarWhereInput;
  data: EmployeeTranslationUpdateManyDataInput;
}

export interface EmployeeTranslationUpdateManyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface EmployeeUpdateManyMutationInput {
  email?: Maybe<String>;
  gender?: Maybe<Gender>;
  tel?: Maybe<String>;
}

export interface EmployeePositionUpdateInput {
  translation?: Maybe<
    EmployeePositionTranslationUpdateManyWithoutPositionInput
  >;
}

export interface EmployeePositionTranslationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  language: LanguageCreateOneInput;
  position: EmployeePositionCreateOneWithoutTranslationInput;
}

export interface EmployeePositionCreateOneWithoutTranslationInput {
  create?: Maybe<EmployeePositionCreateWithoutTranslationInput>;
  connect?: Maybe<EmployeePositionWhereUniqueInput>;
}

export interface EmployeePositionCreateWithoutTranslationInput {
  id?: Maybe<ID_Input>;
}

export interface EmployeePositionTranslationUpdateInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
  position?: Maybe<EmployeePositionUpdateOneRequiredWithoutTranslationInput>;
}

export interface EmployeePositionUpdateOneRequiredWithoutTranslationInput {
  create?: Maybe<EmployeePositionCreateWithoutTranslationInput>;
  connect?: Maybe<EmployeePositionWhereUniqueInput>;
}

export interface EmployeePositionTranslationUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface EmployeeTranslationUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface EmployeeTranslationUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface ExpertCreateInput {
  id?: Maybe<ID_Input>;
  workExperience?: Maybe<String>;
  inpDate?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  web?: Maybe<String>;
  tel?: Maybe<String>;
  mobile?: Maybe<String>;
  publications?: Maybe<String>;
  translation?: Maybe<ExpertTranslationCreateManyInput>;
  oecds?: Maybe<OecdCreateManyInput>;
  languages?: Maybe<LanguageCreateManyInput>;
  author: UserCreateOneInput;
}

export interface ExpertTranslationCreateManyInput {
  create?: Maybe<ExpertTranslationCreateInput[] | ExpertTranslationCreateInput>;
  connect?: Maybe<
    ExpertTranslationWhereUniqueInput[] | ExpertTranslationWhereUniqueInput
  >;
}

export interface ExpertTranslationCreateInput {
  id?: Maybe<ID_Input>;
  fullName?: Maybe<String>;
  qualification?: Maybe<String>;
  academicDegree?: Maybe<String>;
  specialization?: Maybe<String>;
  workingPlace?: Maybe<String>;
  position?: Maybe<String>;
  language: LanguageCreateOneInput;
}

export interface OecdCreateManyInput {
  create?: Maybe<OecdCreateInput[] | OecdCreateInput>;
  connect?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
}

export interface OecdCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  translation?: Maybe<OecdTranslationCreateManyInput>;
  author: UserCreateOneWithoutOecdsInput;
}

export interface OecdTranslationCreateManyInput {
  create?: Maybe<OecdTranslationCreateInput[] | OecdTranslationCreateInput>;
  connect?: Maybe<
    OecdTranslationWhereUniqueInput[] | OecdTranslationWhereUniqueInput
  >;
}

export interface OecdTranslationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  language: LanguageCreateOneInput;
}

export interface UserCreateOneWithoutOecdsInput {
  create?: Maybe<UserCreateWithoutOecdsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutOecdsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  news?: Maybe<NewsCreateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationCreateManyInput>;
}

export interface NewsCreateManyWithoutAuthorInput {
  create?: Maybe<NewsCreateWithoutAuthorInput[] | NewsCreateWithoutAuthorInput>;
  connect?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
}

export interface NewsCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  translation?: Maybe<NewsTranslationCreateManyInput>;
}

export interface NewsTranslationCreateManyInput {
  create?: Maybe<NewsTranslationCreateInput[] | NewsTranslationCreateInput>;
  connect?: Maybe<
    NewsTranslationWhereUniqueInput[] | NewsTranslationWhereUniqueInput
  >;
}

export interface NewsTranslationCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  language: LanguageCreateOneInput;
}

export interface UserTranslationCreateManyInput {
  create?: Maybe<UserTranslationCreateInput[] | UserTranslationCreateInput>;
  connect?: Maybe<
    UserTranslationWhereUniqueInput[] | UserTranslationWhereUniqueInput
  >;
}

export interface UserTranslationCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  language: LanguageCreateOneInput;
}

export interface LanguageCreateManyInput {
  create?: Maybe<LanguageCreateInput[] | LanguageCreateInput>;
  connect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  news?: Maybe<NewsCreateManyWithoutAuthorInput>;
  oecds?: Maybe<OecdCreateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationCreateManyInput>;
}

export interface OecdCreateManyWithoutAuthorInput {
  create?: Maybe<OecdCreateWithoutAuthorInput[] | OecdCreateWithoutAuthorInput>;
  connect?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
}

export interface OecdCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  code: String;
  translation?: Maybe<OecdTranslationCreateManyInput>;
}

export interface ExpertUpdateInput {
  workExperience?: Maybe<String>;
  inpDate?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  web?: Maybe<String>;
  tel?: Maybe<String>;
  mobile?: Maybe<String>;
  publications?: Maybe<String>;
  translation?: Maybe<ExpertTranslationUpdateManyInput>;
  oecds?: Maybe<OecdUpdateManyInput>;
  languages?: Maybe<LanguageUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ExpertTranslationUpdateManyInput {
  create?: Maybe<ExpertTranslationCreateInput[] | ExpertTranslationCreateInput>;
  update?: Maybe<
    | ExpertTranslationUpdateWithWhereUniqueNestedInput[]
    | ExpertTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ExpertTranslationUpsertWithWhereUniqueNestedInput[]
    | ExpertTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ExpertTranslationWhereUniqueInput[] | ExpertTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    ExpertTranslationWhereUniqueInput[] | ExpertTranslationWhereUniqueInput
  >;
  set?: Maybe<
    ExpertTranslationWhereUniqueInput[] | ExpertTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    ExpertTranslationWhereUniqueInput[] | ExpertTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ExpertTranslationScalarWhereInput[] | ExpertTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ExpertTranslationUpdateManyWithWhereNestedInput[]
    | ExpertTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface ExpertTranslationUpdateWithWhereUniqueNestedInput {
  where: ExpertTranslationWhereUniqueInput;
  data: ExpertTranslationUpdateDataInput;
}

export interface ExpertTranslationUpdateDataInput {
  fullName?: Maybe<String>;
  qualification?: Maybe<String>;
  academicDegree?: Maybe<String>;
  specialization?: Maybe<String>;
  workingPlace?: Maybe<String>;
  position?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface ExpertTranslationUpsertWithWhereUniqueNestedInput {
  where: ExpertTranslationWhereUniqueInput;
  update: ExpertTranslationUpdateDataInput;
  create: ExpertTranslationCreateInput;
}

export interface ExpertTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  fullName?: Maybe<String>;
  fullName_not?: Maybe<String>;
  fullName_in?: Maybe<String[] | String>;
  fullName_not_in?: Maybe<String[] | String>;
  fullName_lt?: Maybe<String>;
  fullName_lte?: Maybe<String>;
  fullName_gt?: Maybe<String>;
  fullName_gte?: Maybe<String>;
  fullName_contains?: Maybe<String>;
  fullName_not_contains?: Maybe<String>;
  fullName_starts_with?: Maybe<String>;
  fullName_not_starts_with?: Maybe<String>;
  fullName_ends_with?: Maybe<String>;
  fullName_not_ends_with?: Maybe<String>;
  qualification?: Maybe<String>;
  qualification_not?: Maybe<String>;
  qualification_in?: Maybe<String[] | String>;
  qualification_not_in?: Maybe<String[] | String>;
  qualification_lt?: Maybe<String>;
  qualification_lte?: Maybe<String>;
  qualification_gt?: Maybe<String>;
  qualification_gte?: Maybe<String>;
  qualification_contains?: Maybe<String>;
  qualification_not_contains?: Maybe<String>;
  qualification_starts_with?: Maybe<String>;
  qualification_not_starts_with?: Maybe<String>;
  qualification_ends_with?: Maybe<String>;
  qualification_not_ends_with?: Maybe<String>;
  academicDegree?: Maybe<String>;
  academicDegree_not?: Maybe<String>;
  academicDegree_in?: Maybe<String[] | String>;
  academicDegree_not_in?: Maybe<String[] | String>;
  academicDegree_lt?: Maybe<String>;
  academicDegree_lte?: Maybe<String>;
  academicDegree_gt?: Maybe<String>;
  academicDegree_gte?: Maybe<String>;
  academicDegree_contains?: Maybe<String>;
  academicDegree_not_contains?: Maybe<String>;
  academicDegree_starts_with?: Maybe<String>;
  academicDegree_not_starts_with?: Maybe<String>;
  academicDegree_ends_with?: Maybe<String>;
  academicDegree_not_ends_with?: Maybe<String>;
  specialization?: Maybe<String>;
  specialization_not?: Maybe<String>;
  specialization_in?: Maybe<String[] | String>;
  specialization_not_in?: Maybe<String[] | String>;
  specialization_lt?: Maybe<String>;
  specialization_lte?: Maybe<String>;
  specialization_gt?: Maybe<String>;
  specialization_gte?: Maybe<String>;
  specialization_contains?: Maybe<String>;
  specialization_not_contains?: Maybe<String>;
  specialization_starts_with?: Maybe<String>;
  specialization_not_starts_with?: Maybe<String>;
  specialization_ends_with?: Maybe<String>;
  specialization_not_ends_with?: Maybe<String>;
  workingPlace?: Maybe<String>;
  workingPlace_not?: Maybe<String>;
  workingPlace_in?: Maybe<String[] | String>;
  workingPlace_not_in?: Maybe<String[] | String>;
  workingPlace_lt?: Maybe<String>;
  workingPlace_lte?: Maybe<String>;
  workingPlace_gt?: Maybe<String>;
  workingPlace_gte?: Maybe<String>;
  workingPlace_contains?: Maybe<String>;
  workingPlace_not_contains?: Maybe<String>;
  workingPlace_starts_with?: Maybe<String>;
  workingPlace_not_starts_with?: Maybe<String>;
  workingPlace_ends_with?: Maybe<String>;
  workingPlace_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ExpertTranslationScalarWhereInput[] | ExpertTranslationScalarWhereInput
  >;
  OR?: Maybe<
    ExpertTranslationScalarWhereInput[] | ExpertTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    ExpertTranslationScalarWhereInput[] | ExpertTranslationScalarWhereInput
  >;
}

export interface ExpertTranslationUpdateManyWithWhereNestedInput {
  where: ExpertTranslationScalarWhereInput;
  data: ExpertTranslationUpdateManyDataInput;
}

export interface ExpertTranslationUpdateManyDataInput {
  fullName?: Maybe<String>;
  qualification?: Maybe<String>;
  academicDegree?: Maybe<String>;
  specialization?: Maybe<String>;
  workingPlace?: Maybe<String>;
  position?: Maybe<String>;
}

export interface OecdUpdateManyInput {
  create?: Maybe<OecdCreateInput[] | OecdCreateInput>;
  update?: Maybe<
    | OecdUpdateWithWhereUniqueNestedInput[]
    | OecdUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OecdUpsertWithWhereUniqueNestedInput[]
    | OecdUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  connect?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  set?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  disconnect?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  deleteMany?: Maybe<OecdScalarWhereInput[] | OecdScalarWhereInput>;
  updateMany?: Maybe<
    OecdUpdateManyWithWhereNestedInput[] | OecdUpdateManyWithWhereNestedInput
  >;
}

export interface OecdUpdateWithWhereUniqueNestedInput {
  where: OecdWhereUniqueInput;
  data: OecdUpdateDataInput;
}

export interface OecdUpdateDataInput {
  code?: Maybe<String>;
  translation?: Maybe<OecdTranslationUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutOecdsInput>;
}

export interface OecdTranslationUpdateManyInput {
  create?: Maybe<OecdTranslationCreateInput[] | OecdTranslationCreateInput>;
  update?: Maybe<
    | OecdTranslationUpdateWithWhereUniqueNestedInput[]
    | OecdTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OecdTranslationUpsertWithWhereUniqueNestedInput[]
    | OecdTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    OecdTranslationWhereUniqueInput[] | OecdTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    OecdTranslationWhereUniqueInput[] | OecdTranslationWhereUniqueInput
  >;
  set?: Maybe<
    OecdTranslationWhereUniqueInput[] | OecdTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    OecdTranslationWhereUniqueInput[] | OecdTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    OecdTranslationScalarWhereInput[] | OecdTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | OecdTranslationUpdateManyWithWhereNestedInput[]
    | OecdTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface OecdTranslationUpdateWithWhereUniqueNestedInput {
  where: OecdTranslationWhereUniqueInput;
  data: OecdTranslationUpdateDataInput;
}

export interface OecdTranslationUpdateDataInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface OecdTranslationUpsertWithWhereUniqueNestedInput {
  where: OecdTranslationWhereUniqueInput;
  update: OecdTranslationUpdateDataInput;
  create: OecdTranslationCreateInput;
}

export interface OecdTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    OecdTranslationScalarWhereInput[] | OecdTranslationScalarWhereInput
  >;
  OR?: Maybe<
    OecdTranslationScalarWhereInput[] | OecdTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    OecdTranslationScalarWhereInput[] | OecdTranslationScalarWhereInput
  >;
}

export interface OecdTranslationUpdateManyWithWhereNestedInput {
  where: OecdTranslationScalarWhereInput;
  data: OecdTranslationUpdateManyDataInput;
}

export interface OecdTranslationUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutOecdsInput {
  create?: Maybe<UserCreateWithoutOecdsInput>;
  update?: Maybe<UserUpdateWithoutOecdsDataInput>;
  upsert?: Maybe<UserUpsertWithoutOecdsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutOecdsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  news?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationUpdateManyInput>;
}

export interface NewsUpdateManyWithoutAuthorInput {
  create?: Maybe<NewsCreateWithoutAuthorInput[] | NewsCreateWithoutAuthorInput>;
  delete?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  connect?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  set?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  disconnect?: Maybe<NewsWhereUniqueInput[] | NewsWhereUniqueInput>;
  update?: Maybe<
    | NewsUpdateWithWhereUniqueWithoutAuthorInput[]
    | NewsUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | NewsUpsertWithWhereUniqueWithoutAuthorInput[]
    | NewsUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
}

export interface NewsUpdateWithWhereUniqueWithoutAuthorInput {
  where: NewsWhereUniqueInput;
  data: NewsUpdateWithoutAuthorDataInput;
}

export interface NewsUpdateWithoutAuthorDataInput {
  translation?: Maybe<NewsTranslationUpdateManyInput>;
}

export interface NewsTranslationUpdateManyInput {
  create?: Maybe<NewsTranslationCreateInput[] | NewsTranslationCreateInput>;
  update?: Maybe<
    | NewsTranslationUpdateWithWhereUniqueNestedInput[]
    | NewsTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | NewsTranslationUpsertWithWhereUniqueNestedInput[]
    | NewsTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    NewsTranslationWhereUniqueInput[] | NewsTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    NewsTranslationWhereUniqueInput[] | NewsTranslationWhereUniqueInput
  >;
  set?: Maybe<
    NewsTranslationWhereUniqueInput[] | NewsTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    NewsTranslationWhereUniqueInput[] | NewsTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    NewsTranslationScalarWhereInput[] | NewsTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | NewsTranslationUpdateManyWithWhereNestedInput[]
    | NewsTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface NewsTranslationUpdateWithWhereUniqueNestedInput {
  where: NewsTranslationWhereUniqueInput;
  data: NewsTranslationUpdateDataInput;
}

export interface NewsTranslationUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface NewsTranslationUpsertWithWhereUniqueNestedInput {
  where: NewsTranslationWhereUniqueInput;
  update: NewsTranslationUpdateDataInput;
  create: NewsTranslationCreateInput;
}

export interface NewsTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    NewsTranslationScalarWhereInput[] | NewsTranslationScalarWhereInput
  >;
  OR?: Maybe<
    NewsTranslationScalarWhereInput[] | NewsTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    NewsTranslationScalarWhereInput[] | NewsTranslationScalarWhereInput
  >;
}

export interface NewsTranslationUpdateManyWithWhereNestedInput {
  where: NewsTranslationScalarWhereInput;
  data: NewsTranslationUpdateManyDataInput;
}

export interface NewsTranslationUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
}

export interface NewsUpsertWithWhereUniqueWithoutAuthorInput {
  where: NewsWhereUniqueInput;
  update: NewsUpdateWithoutAuthorDataInput;
  create: NewsCreateWithoutAuthorInput;
}

export interface NewsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
  OR?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
  NOT?: Maybe<NewsScalarWhereInput[] | NewsScalarWhereInput>;
}

export interface UserTranslationUpdateManyInput {
  create?: Maybe<UserTranslationCreateInput[] | UserTranslationCreateInput>;
  update?: Maybe<
    | UserTranslationUpdateWithWhereUniqueNestedInput[]
    | UserTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserTranslationUpsertWithWhereUniqueNestedInput[]
    | UserTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    UserTranslationWhereUniqueInput[] | UserTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    UserTranslationWhereUniqueInput[] | UserTranslationWhereUniqueInput
  >;
  set?: Maybe<
    UserTranslationWhereUniqueInput[] | UserTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserTranslationWhereUniqueInput[] | UserTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    UserTranslationScalarWhereInput[] | UserTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserTranslationUpdateManyWithWhereNestedInput[]
    | UserTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface UserTranslationUpdateWithWhereUniqueNestedInput {
  where: UserTranslationWhereUniqueInput;
  data: UserTranslationUpdateDataInput;
}

export interface UserTranslationUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface UserTranslationUpsertWithWhereUniqueNestedInput {
  where: UserTranslationWhereUniqueInput;
  update: UserTranslationUpdateDataInput;
  create: UserTranslationCreateInput;
}

export interface UserTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    UserTranslationScalarWhereInput[] | UserTranslationScalarWhereInput
  >;
  OR?: Maybe<
    UserTranslationScalarWhereInput[] | UserTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    UserTranslationScalarWhereInput[] | UserTranslationScalarWhereInput
  >;
}

export interface UserTranslationUpdateManyWithWhereNestedInput {
  where: UserTranslationScalarWhereInput;
  data: UserTranslationUpdateManyDataInput;
}

export interface UserTranslationUpdateManyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface UserUpsertWithoutOecdsInput {
  update: UserUpdateWithoutOecdsDataInput;
  create: UserCreateWithoutOecdsInput;
}

export interface OecdUpsertWithWhereUniqueNestedInput {
  where: OecdWhereUniqueInput;
  update: OecdUpdateDataInput;
  create: OecdCreateInput;
}

export interface OecdScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  AND?: Maybe<OecdScalarWhereInput[] | OecdScalarWhereInput>;
  OR?: Maybe<OecdScalarWhereInput[] | OecdScalarWhereInput>;
  NOT?: Maybe<OecdScalarWhereInput[] | OecdScalarWhereInput>;
}

export interface OecdUpdateManyWithWhereNestedInput {
  where: OecdScalarWhereInput;
  data: OecdUpdateManyDataInput;
}

export interface OecdUpdateManyDataInput {
  code?: Maybe<String>;
}

export interface LanguageUpdateManyInput {
  create?: Maybe<LanguageCreateInput[] | LanguageCreateInput>;
  update?: Maybe<
    | LanguageUpdateWithWhereUniqueNestedInput[]
    | LanguageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | LanguageUpsertWithWhereUniqueNestedInput[]
    | LanguageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  connect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  set?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  disconnect?: Maybe<LanguageWhereUniqueInput[] | LanguageWhereUniqueInput>;
  deleteMany?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  updateMany?: Maybe<
    | LanguageUpdateManyWithWhereNestedInput[]
    | LanguageUpdateManyWithWhereNestedInput
  >;
}

export interface LanguageUpdateWithWhereUniqueNestedInput {
  where: LanguageWhereUniqueInput;
  data: LanguageUpdateDataInput;
}

export interface LanguageUpsertWithWhereUniqueNestedInput {
  where: LanguageWhereUniqueInput;
  update: LanguageUpdateDataInput;
  create: LanguageCreateInput;
}

export interface LanguageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  code?: Maybe<LanguageCode>;
  code_not?: Maybe<LanguageCode>;
  code_in?: Maybe<LanguageCode[] | LanguageCode>;
  code_not_in?: Maybe<LanguageCode[] | LanguageCode>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  OR?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
  NOT?: Maybe<LanguageScalarWhereInput[] | LanguageScalarWhereInput>;
}

export interface LanguageUpdateManyWithWhereNestedInput {
  where: LanguageScalarWhereInput;
  data: LanguageUpdateManyDataInput;
}

export interface LanguageUpdateManyDataInput {
  code?: Maybe<LanguageCode>;
  name?: Maybe<String>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  news?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  oecds?: Maybe<OecdUpdateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationUpdateManyInput>;
}

export interface OecdUpdateManyWithoutAuthorInput {
  create?: Maybe<OecdCreateWithoutAuthorInput[] | OecdCreateWithoutAuthorInput>;
  delete?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  connect?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  set?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  disconnect?: Maybe<OecdWhereUniqueInput[] | OecdWhereUniqueInput>;
  update?: Maybe<
    | OecdUpdateWithWhereUniqueWithoutAuthorInput[]
    | OecdUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | OecdUpsertWithWhereUniqueWithoutAuthorInput[]
    | OecdUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<OecdScalarWhereInput[] | OecdScalarWhereInput>;
  updateMany?: Maybe<
    OecdUpdateManyWithWhereNestedInput[] | OecdUpdateManyWithWhereNestedInput
  >;
}

export interface OecdUpdateWithWhereUniqueWithoutAuthorInput {
  where: OecdWhereUniqueInput;
  data: OecdUpdateWithoutAuthorDataInput;
}

export interface OecdUpdateWithoutAuthorDataInput {
  code?: Maybe<String>;
  translation?: Maybe<OecdTranslationUpdateManyInput>;
}

export interface OecdUpsertWithWhereUniqueWithoutAuthorInput {
  where: OecdWhereUniqueInput;
  update: OecdUpdateWithoutAuthorDataInput;
  create: OecdCreateWithoutAuthorInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ExpertUpdateManyMutationInput {
  workExperience?: Maybe<String>;
  inpDate?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  web?: Maybe<String>;
  tel?: Maybe<String>;
  mobile?: Maybe<String>;
  publications?: Maybe<String>;
}

export interface ExpertTranslationUpdateInput {
  fullName?: Maybe<String>;
  qualification?: Maybe<String>;
  academicDegree?: Maybe<String>;
  specialization?: Maybe<String>;
  workingPlace?: Maybe<String>;
  position?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface ExpertTranslationUpdateManyMutationInput {
  fullName?: Maybe<String>;
  qualification?: Maybe<String>;
  academicDegree?: Maybe<String>;
  specialization?: Maybe<String>;
  workingPlace?: Maybe<String>;
  position?: Maybe<String>;
}

export interface JournalCreateInput {
  id?: Maybe<ID_Input>;
  pubNumber: String;
  translation?: Maybe<QrjTranslationCreateManyInput>;
}

export interface QrjTranslationCreateManyInput {
  create?: Maybe<QrjTranslationCreateInput[] | QrjTranslationCreateInput>;
  connect?: Maybe<
    QrjTranslationWhereUniqueInput[] | QrjTranslationWhereUniqueInput
  >;
}

export interface QrjTranslationCreateInput {
  id?: Maybe<ID_Input>;
  address: String;
  language: LanguageCreateOneInput;
}

export interface JournalUpdateInput {
  pubNumber?: Maybe<String>;
  translation?: Maybe<QrjTranslationUpdateManyInput>;
}

export interface QrjTranslationUpdateManyInput {
  create?: Maybe<QrjTranslationCreateInput[] | QrjTranslationCreateInput>;
  update?: Maybe<
    | QrjTranslationUpdateWithWhereUniqueNestedInput[]
    | QrjTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QrjTranslationUpsertWithWhereUniqueNestedInput[]
    | QrjTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QrjTranslationWhereUniqueInput[] | QrjTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    QrjTranslationWhereUniqueInput[] | QrjTranslationWhereUniqueInput
  >;
  set?: Maybe<
    QrjTranslationWhereUniqueInput[] | QrjTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    QrjTranslationWhereUniqueInput[] | QrjTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QrjTranslationScalarWhereInput[] | QrjTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | QrjTranslationUpdateManyWithWhereNestedInput[]
    | QrjTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface QrjTranslationUpdateWithWhereUniqueNestedInput {
  where: QrjTranslationWhereUniqueInput;
  data: QrjTranslationUpdateDataInput;
}

export interface QrjTranslationUpdateDataInput {
  address?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface QrjTranslationUpsertWithWhereUniqueNestedInput {
  where: QrjTranslationWhereUniqueInput;
  update: QrjTranslationUpdateDataInput;
  create: QrjTranslationCreateInput;
}

export interface QrjTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QrjTranslationScalarWhereInput[] | QrjTranslationScalarWhereInput
  >;
  OR?: Maybe<QrjTranslationScalarWhereInput[] | QrjTranslationScalarWhereInput>;
  NOT?: Maybe<
    QrjTranslationScalarWhereInput[] | QrjTranslationScalarWhereInput
  >;
}

export interface QrjTranslationUpdateManyWithWhereNestedInput {
  where: QrjTranslationScalarWhereInput;
  data: QrjTranslationUpdateManyDataInput;
}

export interface QrjTranslationUpdateManyDataInput {
  address?: Maybe<String>;
}

export interface JournalUpdateManyMutationInput {
  pubNumber?: Maybe<String>;
}

export interface KeywordCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface KeywordUpdateInput {
  name?: Maybe<String>;
}

export interface KeywordUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface LanguageUpdateInput {
  code?: Maybe<LanguageCode>;
  name?: Maybe<String>;
}

export interface LanguageUpdateManyMutationInput {
  code?: Maybe<LanguageCode>;
  name?: Maybe<String>;
}

export interface NewsCreateInput {
  id?: Maybe<ID_Input>;
  translation?: Maybe<NewsTranslationCreateManyInput>;
  author: UserCreateOneWithoutNewsInput;
}

export interface UserCreateOneWithoutNewsInput {
  create?: Maybe<UserCreateWithoutNewsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutNewsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  oecds?: Maybe<OecdCreateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationCreateManyInput>;
}

export interface NewsUpdateInput {
  translation?: Maybe<NewsTranslationUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutNewsInput>;
}

export interface UserUpdateOneRequiredWithoutNewsInput {
  create?: Maybe<UserCreateWithoutNewsInput>;
  update?: Maybe<UserUpdateWithoutNewsDataInput>;
  upsert?: Maybe<UserUpsertWithoutNewsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutNewsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  oecds?: Maybe<OecdUpdateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationUpdateManyInput>;
}

export interface UserUpsertWithoutNewsInput {
  update: UserUpdateWithoutNewsDataInput;
  create: UserCreateWithoutNewsInput;
}

export interface NewsTranslationUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface NewsTranslationUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  content?: Maybe<String>;
}

export interface OecdUpdateInput {
  code?: Maybe<String>;
  translation?: Maybe<OecdTranslationUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutOecdsInput>;
}

export interface OecdUpdateManyMutationInput {
  code?: Maybe<String>;
}

export interface OecdTranslationUpdateInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface OecdTranslationUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface QrjCreateInput {
  id?: Maybe<ID_Input>;
  year: String;
  journal?: Maybe<JournalCreateManyInput>;
  author: UserCreateOneInput;
}

export interface JournalCreateManyInput {
  create?: Maybe<JournalCreateInput[] | JournalCreateInput>;
  connect?: Maybe<JournalWhereUniqueInput[] | JournalWhereUniqueInput>;
}

export interface QrjUpdateInput {
  year?: Maybe<String>;
  journal?: Maybe<JournalUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface JournalUpdateManyInput {
  create?: Maybe<JournalCreateInput[] | JournalCreateInput>;
  update?: Maybe<
    | JournalUpdateWithWhereUniqueNestedInput[]
    | JournalUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | JournalUpsertWithWhereUniqueNestedInput[]
    | JournalUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<JournalWhereUniqueInput[] | JournalWhereUniqueInput>;
  connect?: Maybe<JournalWhereUniqueInput[] | JournalWhereUniqueInput>;
  set?: Maybe<JournalWhereUniqueInput[] | JournalWhereUniqueInput>;
  disconnect?: Maybe<JournalWhereUniqueInput[] | JournalWhereUniqueInput>;
  deleteMany?: Maybe<JournalScalarWhereInput[] | JournalScalarWhereInput>;
  updateMany?: Maybe<
    | JournalUpdateManyWithWhereNestedInput[]
    | JournalUpdateManyWithWhereNestedInput
  >;
}

export interface JournalUpdateWithWhereUniqueNestedInput {
  where: JournalWhereUniqueInput;
  data: JournalUpdateDataInput;
}

export interface JournalUpdateDataInput {
  pubNumber?: Maybe<String>;
  translation?: Maybe<QrjTranslationUpdateManyInput>;
}

export interface JournalUpsertWithWhereUniqueNestedInput {
  where: JournalWhereUniqueInput;
  update: JournalUpdateDataInput;
  create: JournalCreateInput;
}

export interface JournalScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pubNumber?: Maybe<String>;
  pubNumber_not?: Maybe<String>;
  pubNumber_in?: Maybe<String[] | String>;
  pubNumber_not_in?: Maybe<String[] | String>;
  pubNumber_lt?: Maybe<String>;
  pubNumber_lte?: Maybe<String>;
  pubNumber_gt?: Maybe<String>;
  pubNumber_gte?: Maybe<String>;
  pubNumber_contains?: Maybe<String>;
  pubNumber_not_contains?: Maybe<String>;
  pubNumber_starts_with?: Maybe<String>;
  pubNumber_not_starts_with?: Maybe<String>;
  pubNumber_ends_with?: Maybe<String>;
  pubNumber_not_ends_with?: Maybe<String>;
  AND?: Maybe<JournalScalarWhereInput[] | JournalScalarWhereInput>;
  OR?: Maybe<JournalScalarWhereInput[] | JournalScalarWhereInput>;
  NOT?: Maybe<JournalScalarWhereInput[] | JournalScalarWhereInput>;
}

export interface JournalUpdateManyWithWhereNestedInput {
  where: JournalScalarWhereInput;
  data: JournalUpdateManyDataInput;
}

export interface JournalUpdateManyDataInput {
  pubNumber?: Maybe<String>;
}

export interface QrjUpdateManyMutationInput {
  year?: Maybe<String>;
}

export interface QrjJournalCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  translation?: Maybe<QrjJournalTranslationCreateManyInput>;
  author: UserCreateOneInput;
}

export interface QrjJournalTranslationCreateManyInput {
  create?: Maybe<
    QrjJournalTranslationCreateInput[] | QrjJournalTranslationCreateInput
  >;
  connect?: Maybe<
    | QrjJournalTranslationWhereUniqueInput[]
    | QrjJournalTranslationWhereUniqueInput
  >;
}

export interface QrjJournalTranslationCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  address?: Maybe<String>;
  language: LanguageCreateOneInput;
}

export interface QrjJournalUpdateInput {
  code?: Maybe<String>;
  translation?: Maybe<QrjJournalTranslationUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface QrjJournalTranslationUpdateManyInput {
  create?: Maybe<
    QrjJournalTranslationCreateInput[] | QrjJournalTranslationCreateInput
  >;
  update?: Maybe<
    | QrjJournalTranslationUpdateWithWhereUniqueNestedInput[]
    | QrjJournalTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QrjJournalTranslationUpsertWithWhereUniqueNestedInput[]
    | QrjJournalTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | QrjJournalTranslationWhereUniqueInput[]
    | QrjJournalTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    | QrjJournalTranslationWhereUniqueInput[]
    | QrjJournalTranslationWhereUniqueInput
  >;
  set?: Maybe<
    | QrjJournalTranslationWhereUniqueInput[]
    | QrjJournalTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    | QrjJournalTranslationWhereUniqueInput[]
    | QrjJournalTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | QrjJournalTranslationScalarWhereInput[]
    | QrjJournalTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | QrjJournalTranslationUpdateManyWithWhereNestedInput[]
    | QrjJournalTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface QrjJournalTranslationUpdateWithWhereUniqueNestedInput {
  where: QrjJournalTranslationWhereUniqueInput;
  data: QrjJournalTranslationUpdateDataInput;
}

export interface QrjJournalTranslationUpdateDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface QrjJournalTranslationUpsertWithWhereUniqueNestedInput {
  where: QrjJournalTranslationWhereUniqueInput;
  update: QrjJournalTranslationUpdateDataInput;
  create: QrjJournalTranslationCreateInput;
}

export interface QrjJournalTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | QrjJournalTranslationScalarWhereInput[]
    | QrjJournalTranslationScalarWhereInput
  >;
  OR?: Maybe<
    | QrjJournalTranslationScalarWhereInput[]
    | QrjJournalTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    | QrjJournalTranslationScalarWhereInput[]
    | QrjJournalTranslationScalarWhereInput
  >;
}

export interface QrjJournalTranslationUpdateManyWithWhereNestedInput {
  where: QrjJournalTranslationScalarWhereInput;
  data: QrjJournalTranslationUpdateManyDataInput;
}

export interface QrjJournalTranslationUpdateManyDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface QrjJournalUpdateManyMutationInput {
  code?: Maybe<String>;
}

export interface QrjJournalTranslationUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface QrjJournalTranslationUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
}

export interface QrjPublicationCreateInput {
  id?: Maybe<ID_Input>;
  index: String;
  edited?: Maybe<Boolean>;
  year?: Maybe<String>;
  number?: Maybe<String>;
  pages?: Maybe<String>;
  doiUrl?: Maybe<String>;
  journal?: Maybe<QrjJournalCreateOneInput>;
  inputDate?: Maybe<DateTimeInput>;
  oecd?: Maybe<OecdCreateOneInput>;
  translation?: Maybe<QrjPublicationTranslationCreateManyInput>;
  author: UserCreateOneInput;
}

export interface QrjJournalCreateOneInput {
  create?: Maybe<QrjJournalCreateInput>;
  connect?: Maybe<QrjJournalWhereUniqueInput>;
}

export interface OecdCreateOneInput {
  create?: Maybe<OecdCreateInput>;
  connect?: Maybe<OecdWhereUniqueInput>;
}

export interface QrjPublicationTranslationCreateManyInput {
  create?: Maybe<
    | QrjPublicationTranslationCreateInput[]
    | QrjPublicationTranslationCreateInput
  >;
  connect?: Maybe<
    | QrjPublicationTranslationWhereUniqueInput[]
    | QrjPublicationTranslationWhereUniqueInput
  >;
}

export interface QrjPublicationTranslationCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationLang?: Maybe<String>;
  abstract?: Maybe<String>;
  language: LanguageCreateOneInput;
}

export interface QrjPublicationUpdateInput {
  index?: Maybe<String>;
  edited?: Maybe<Boolean>;
  year?: Maybe<String>;
  number?: Maybe<String>;
  pages?: Maybe<String>;
  doiUrl?: Maybe<String>;
  journal?: Maybe<QrjJournalUpdateOneInput>;
  inputDate?: Maybe<DateTimeInput>;
  oecd?: Maybe<OecdUpdateOneInput>;
  translation?: Maybe<QrjPublicationTranslationUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface QrjJournalUpdateOneInput {
  create?: Maybe<QrjJournalCreateInput>;
  update?: Maybe<QrjJournalUpdateDataInput>;
  upsert?: Maybe<QrjJournalUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<QrjJournalWhereUniqueInput>;
}

export interface QrjJournalUpdateDataInput {
  code?: Maybe<String>;
  translation?: Maybe<QrjJournalTranslationUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface QrjJournalUpsertNestedInput {
  update: QrjJournalUpdateDataInput;
  create: QrjJournalCreateInput;
}

export interface OecdUpdateOneInput {
  create?: Maybe<OecdCreateInput>;
  update?: Maybe<OecdUpdateDataInput>;
  upsert?: Maybe<OecdUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OecdWhereUniqueInput>;
}

export interface OecdUpsertNestedInput {
  update: OecdUpdateDataInput;
  create: OecdCreateInput;
}

export interface QrjPublicationTranslationUpdateManyInput {
  create?: Maybe<
    | QrjPublicationTranslationCreateInput[]
    | QrjPublicationTranslationCreateInput
  >;
  update?: Maybe<
    | QrjPublicationTranslationUpdateWithWhereUniqueNestedInput[]
    | QrjPublicationTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QrjPublicationTranslationUpsertWithWhereUniqueNestedInput[]
    | QrjPublicationTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | QrjPublicationTranslationWhereUniqueInput[]
    | QrjPublicationTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    | QrjPublicationTranslationWhereUniqueInput[]
    | QrjPublicationTranslationWhereUniqueInput
  >;
  set?: Maybe<
    | QrjPublicationTranslationWhereUniqueInput[]
    | QrjPublicationTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    | QrjPublicationTranslationWhereUniqueInput[]
    | QrjPublicationTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | QrjPublicationTranslationScalarWhereInput[]
    | QrjPublicationTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | QrjPublicationTranslationUpdateManyWithWhereNestedInput[]
    | QrjPublicationTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface QrjPublicationTranslationUpdateWithWhereUniqueNestedInput {
  where: QrjPublicationTranslationWhereUniqueInput;
  data: QrjPublicationTranslationUpdateDataInput;
}

export interface QrjPublicationTranslationUpdateDataInput {
  title?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationLang?: Maybe<String>;
  abstract?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface QrjPublicationTranslationUpsertWithWhereUniqueNestedInput {
  where: QrjPublicationTranslationWhereUniqueInput;
  update: QrjPublicationTranslationUpdateDataInput;
  create: QrjPublicationTranslationCreateInput;
}

export interface QrjPublicationTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationAuthor_not?: Maybe<String>;
  publicationAuthor_in?: Maybe<String[] | String>;
  publicationAuthor_not_in?: Maybe<String[] | String>;
  publicationAuthor_lt?: Maybe<String>;
  publicationAuthor_lte?: Maybe<String>;
  publicationAuthor_gt?: Maybe<String>;
  publicationAuthor_gte?: Maybe<String>;
  publicationAuthor_contains?: Maybe<String>;
  publicationAuthor_not_contains?: Maybe<String>;
  publicationAuthor_starts_with?: Maybe<String>;
  publicationAuthor_not_starts_with?: Maybe<String>;
  publicationAuthor_ends_with?: Maybe<String>;
  publicationAuthor_not_ends_with?: Maybe<String>;
  publicationLang?: Maybe<String>;
  publicationLang_not?: Maybe<String>;
  publicationLang_in?: Maybe<String[] | String>;
  publicationLang_not_in?: Maybe<String[] | String>;
  publicationLang_lt?: Maybe<String>;
  publicationLang_lte?: Maybe<String>;
  publicationLang_gt?: Maybe<String>;
  publicationLang_gte?: Maybe<String>;
  publicationLang_contains?: Maybe<String>;
  publicationLang_not_contains?: Maybe<String>;
  publicationLang_starts_with?: Maybe<String>;
  publicationLang_not_starts_with?: Maybe<String>;
  publicationLang_ends_with?: Maybe<String>;
  publicationLang_not_ends_with?: Maybe<String>;
  abstract?: Maybe<String>;
  abstract_not?: Maybe<String>;
  abstract_in?: Maybe<String[] | String>;
  abstract_not_in?: Maybe<String[] | String>;
  abstract_lt?: Maybe<String>;
  abstract_lte?: Maybe<String>;
  abstract_gt?: Maybe<String>;
  abstract_gte?: Maybe<String>;
  abstract_contains?: Maybe<String>;
  abstract_not_contains?: Maybe<String>;
  abstract_starts_with?: Maybe<String>;
  abstract_not_starts_with?: Maybe<String>;
  abstract_ends_with?: Maybe<String>;
  abstract_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | QrjPublicationTranslationScalarWhereInput[]
    | QrjPublicationTranslationScalarWhereInput
  >;
  OR?: Maybe<
    | QrjPublicationTranslationScalarWhereInput[]
    | QrjPublicationTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    | QrjPublicationTranslationScalarWhereInput[]
    | QrjPublicationTranslationScalarWhereInput
  >;
}

export interface QrjPublicationTranslationUpdateManyWithWhereNestedInput {
  where: QrjPublicationTranslationScalarWhereInput;
  data: QrjPublicationTranslationUpdateManyDataInput;
}

export interface QrjPublicationTranslationUpdateManyDataInput {
  title?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationLang?: Maybe<String>;
  abstract?: Maybe<String>;
}

export interface QrjPublicationUpdateManyMutationInput {
  index?: Maybe<String>;
  edited?: Maybe<Boolean>;
  year?: Maybe<String>;
  number?: Maybe<String>;
  pages?: Maybe<String>;
  doiUrl?: Maybe<String>;
  inputDate?: Maybe<DateTimeInput>;
}

export interface QrjPublicationTranslationUpdateInput {
  title?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationLang?: Maybe<String>;
  abstract?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface QrjPublicationTranslationUpdateManyMutationInput {
  title?: Maybe<String>;
  publicationAuthor?: Maybe<String>;
  publicationLang?: Maybe<String>;
  abstract?: Maybe<String>;
}

export interface QrjTranslationUpdateInput {
  address?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface QrjTranslationUpdateManyMutationInput {
  address?: Maybe<String>;
}

export interface ResearchProjectCreateInput {
  id?: Maybe<ID_Input>;
  inpDate?: Maybe<DateTimeInput>;
  regDate?: Maybe<DateTimeInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  regNumb?: Maybe<String>;
  research?: Maybe<String>;
  researchDirection?: Maybe<String>;
  researchExecutionBasis?: Maybe<String>;
  abstract?: Maybe<String>;
  annotation?: Maybe<String>;
  budget?: Maybe<Int>;
  organizationName?: Maybe<String>;
  organizationShortName?: Maybe<String>;
  organizationCode?: Maybe<String>;
  organizationHead?: Maybe<String>;
  organizationCity?: Maybe<String>;
  organizationAddress?: Maybe<String>;
  organizationIndex?: Maybe<String>;
  organizationTel?: Maybe<String>;
  organizationWeb?: Maybe<String>;
  participatingInstitutionName?: Maybe<String>;
  participatingInstitutionCountryCity?: Maybe<String>;
  participatingInstitutionTel?: Maybe<String>;
  participatingInstitutionEmail?: Maybe<String>;
  participatingInstitutionWeb?: Maybe<String>;
  leaderName?: Maybe<String>;
  leaderPosition?: Maybe<String>;
  leaderAcademicDegree?: Maybe<String>;
  leaderTel?: Maybe<String>;
  leaderMobile?: Maybe<String>;
  leaderEmail?: Maybe<String>;
  researchExecutors?: Maybe<String>;
  financing?: Maybe<String>;
  note?: Maybe<String>;
  pincode?: Maybe<String>;
  translation?: Maybe<ResearchProjectTranslationCreateManyInput>;
  oecds?: Maybe<OecdCreateManyInput>;
  author: UserCreateOneInput;
}

export interface ResearchProjectTranslationCreateManyInput {
  create?: Maybe<
    | ResearchProjectTranslationCreateInput[]
    | ResearchProjectTranslationCreateInput
  >;
  connect?: Maybe<
    | ResearchProjectTranslationWhereUniqueInput[]
    | ResearchProjectTranslationWhereUniqueInput
  >;
}

export interface ResearchProjectTranslationCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  key?: Maybe<KeywordCreateManyInput>;
  language: LanguageCreateOneInput;
}

export interface KeywordCreateManyInput {
  create?: Maybe<KeywordCreateInput[] | KeywordCreateInput>;
  connect?: Maybe<KeywordWhereUniqueInput[] | KeywordWhereUniqueInput>;
}

export interface ResearchProjectUpdateInput {
  inpDate?: Maybe<DateTimeInput>;
  regDate?: Maybe<DateTimeInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  regNumb?: Maybe<String>;
  research?: Maybe<String>;
  researchDirection?: Maybe<String>;
  researchExecutionBasis?: Maybe<String>;
  abstract?: Maybe<String>;
  annotation?: Maybe<String>;
  budget?: Maybe<Int>;
  organizationName?: Maybe<String>;
  organizationShortName?: Maybe<String>;
  organizationCode?: Maybe<String>;
  organizationHead?: Maybe<String>;
  organizationCity?: Maybe<String>;
  organizationAddress?: Maybe<String>;
  organizationIndex?: Maybe<String>;
  organizationTel?: Maybe<String>;
  organizationWeb?: Maybe<String>;
  participatingInstitutionName?: Maybe<String>;
  participatingInstitutionCountryCity?: Maybe<String>;
  participatingInstitutionTel?: Maybe<String>;
  participatingInstitutionEmail?: Maybe<String>;
  participatingInstitutionWeb?: Maybe<String>;
  leaderName?: Maybe<String>;
  leaderPosition?: Maybe<String>;
  leaderAcademicDegree?: Maybe<String>;
  leaderTel?: Maybe<String>;
  leaderMobile?: Maybe<String>;
  leaderEmail?: Maybe<String>;
  researchExecutors?: Maybe<String>;
  financing?: Maybe<String>;
  note?: Maybe<String>;
  pincode?: Maybe<String>;
  translation?: Maybe<ResearchProjectTranslationUpdateManyInput>;
  oecds?: Maybe<OecdUpdateManyInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface ResearchProjectTranslationUpdateManyInput {
  create?: Maybe<
    | ResearchProjectTranslationCreateInput[]
    | ResearchProjectTranslationCreateInput
  >;
  update?: Maybe<
    | ResearchProjectTranslationUpdateWithWhereUniqueNestedInput[]
    | ResearchProjectTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ResearchProjectTranslationUpsertWithWhereUniqueNestedInput[]
    | ResearchProjectTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | ResearchProjectTranslationWhereUniqueInput[]
    | ResearchProjectTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    | ResearchProjectTranslationWhereUniqueInput[]
    | ResearchProjectTranslationWhereUniqueInput
  >;
  set?: Maybe<
    | ResearchProjectTranslationWhereUniqueInput[]
    | ResearchProjectTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ResearchProjectTranslationWhereUniqueInput[]
    | ResearchProjectTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | ResearchProjectTranslationScalarWhereInput[]
    | ResearchProjectTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ResearchProjectTranslationUpdateManyWithWhereNestedInput[]
    | ResearchProjectTranslationUpdateManyWithWhereNestedInput
  >;
}

export interface ResearchProjectTranslationUpdateWithWhereUniqueNestedInput {
  where: ResearchProjectTranslationWhereUniqueInput;
  data: ResearchProjectTranslationUpdateDataInput;
}

export interface ResearchProjectTranslationUpdateDataInput {
  title?: Maybe<String>;
  key?: Maybe<KeywordUpdateManyInput>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface KeywordUpdateManyInput {
  create?: Maybe<KeywordCreateInput[] | KeywordCreateInput>;
  update?: Maybe<
    | KeywordUpdateWithWhereUniqueNestedInput[]
    | KeywordUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | KeywordUpsertWithWhereUniqueNestedInput[]
    | KeywordUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<KeywordWhereUniqueInput[] | KeywordWhereUniqueInput>;
  connect?: Maybe<KeywordWhereUniqueInput[] | KeywordWhereUniqueInput>;
  set?: Maybe<KeywordWhereUniqueInput[] | KeywordWhereUniqueInput>;
  disconnect?: Maybe<KeywordWhereUniqueInput[] | KeywordWhereUniqueInput>;
  deleteMany?: Maybe<KeywordScalarWhereInput[] | KeywordScalarWhereInput>;
  updateMany?: Maybe<
    | KeywordUpdateManyWithWhereNestedInput[]
    | KeywordUpdateManyWithWhereNestedInput
  >;
}

export interface KeywordUpdateWithWhereUniqueNestedInput {
  where: KeywordWhereUniqueInput;
  data: KeywordUpdateDataInput;
}

export interface KeywordUpdateDataInput {
  name?: Maybe<String>;
}

export interface KeywordUpsertWithWhereUniqueNestedInput {
  where: KeywordWhereUniqueInput;
  update: KeywordUpdateDataInput;
  create: KeywordCreateInput;
}

export interface KeywordScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<KeywordScalarWhereInput[] | KeywordScalarWhereInput>;
  OR?: Maybe<KeywordScalarWhereInput[] | KeywordScalarWhereInput>;
  NOT?: Maybe<KeywordScalarWhereInput[] | KeywordScalarWhereInput>;
}

export interface KeywordUpdateManyWithWhereNestedInput {
  where: KeywordScalarWhereInput;
  data: KeywordUpdateManyDataInput;
}

export interface KeywordUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ResearchProjectTranslationUpsertWithWhereUniqueNestedInput {
  where: ResearchProjectTranslationWhereUniqueInput;
  update: ResearchProjectTranslationUpdateDataInput;
  create: ResearchProjectTranslationCreateInput;
}

export interface ResearchProjectTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | ResearchProjectTranslationScalarWhereInput[]
    | ResearchProjectTranslationScalarWhereInput
  >;
  OR?: Maybe<
    | ResearchProjectTranslationScalarWhereInput[]
    | ResearchProjectTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    | ResearchProjectTranslationScalarWhereInput[]
    | ResearchProjectTranslationScalarWhereInput
  >;
}

export interface ResearchProjectTranslationUpdateManyWithWhereNestedInput {
  where: ResearchProjectTranslationScalarWhereInput;
  data: ResearchProjectTranslationUpdateManyDataInput;
}

export interface ResearchProjectTranslationUpdateManyDataInput {
  title?: Maybe<String>;
}

export interface ResearchProjectUpdateManyMutationInput {
  inpDate?: Maybe<DateTimeInput>;
  regDate?: Maybe<DateTimeInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  regNumb?: Maybe<String>;
  research?: Maybe<String>;
  researchDirection?: Maybe<String>;
  researchExecutionBasis?: Maybe<String>;
  abstract?: Maybe<String>;
  annotation?: Maybe<String>;
  budget?: Maybe<Int>;
  organizationName?: Maybe<String>;
  organizationShortName?: Maybe<String>;
  organizationCode?: Maybe<String>;
  organizationHead?: Maybe<String>;
  organizationCity?: Maybe<String>;
  organizationAddress?: Maybe<String>;
  organizationIndex?: Maybe<String>;
  organizationTel?: Maybe<String>;
  organizationWeb?: Maybe<String>;
  participatingInstitutionName?: Maybe<String>;
  participatingInstitutionCountryCity?: Maybe<String>;
  participatingInstitutionTel?: Maybe<String>;
  participatingInstitutionEmail?: Maybe<String>;
  participatingInstitutionWeb?: Maybe<String>;
  leaderName?: Maybe<String>;
  leaderPosition?: Maybe<String>;
  leaderAcademicDegree?: Maybe<String>;
  leaderTel?: Maybe<String>;
  leaderMobile?: Maybe<String>;
  leaderEmail?: Maybe<String>;
  researchExecutors?: Maybe<String>;
  financing?: Maybe<String>;
  note?: Maybe<String>;
  pincode?: Maybe<String>;
}

export interface ResearchProjectTranslationUpdateInput {
  title?: Maybe<String>;
  key?: Maybe<KeywordUpdateManyInput>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface ResearchProjectTranslationUpdateManyMutationInput {
  title?: Maybe<String>;
}

export interface TechnologyTransferAndInnovationOrganizationCreateInput {
  id?: Maybe<ID_Input>;
  url?: Maybe<String>;
  title?: Maybe<String>;
  text?: Maybe<String>;
  region?: Maybe<String>;
  author: UserCreateOneInput;
}

export interface TechnologyTransferAndInnovationOrganizationUpdateInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  text?: Maybe<String>;
  region?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TechnologyTransferAndInnovationOrganizationUpdateManyMutationInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  text?: Maybe<String>;
  region?: Maybe<String>;
}

export interface TechnologyTransferNetworkCreateInput {
  id?: Maybe<ID_Input>;
  url?: Maybe<String>;
  title?: Maybe<String>;
  text?: Maybe<String>;
  region?: Maybe<String>;
  author: UserCreateOneInput;
}

export interface TechnologyTransferNetworkUpdateInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  text?: Maybe<String>;
  region?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TechnologyTransferNetworkUpdateManyMutationInput {
  url?: Maybe<String>;
  title?: Maybe<String>;
  text?: Maybe<String>;
  region?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  news?: Maybe<NewsUpdateManyWithoutAuthorInput>;
  oecds?: Maybe<OecdUpdateManyWithoutAuthorInput>;
  role?: Maybe<Role>;
  translation?: Maybe<UserTranslationUpdateManyInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
}

export interface UserTranslationUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface UserTranslationUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface DepartmentTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentTranslationWhereInput>;
  AND?: Maybe<
    | DepartmentTranslationSubscriptionWhereInput[]
    | DepartmentTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DepartmentTranslationSubscriptionWhereInput[]
    | DepartmentTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DepartmentTranslationSubscriptionWhereInput[]
    | DepartmentTranslationSubscriptionWhereInput
  >;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
  OR?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  NOT?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
}

export interface EmployeePositionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeePositionWhereInput>;
  AND?: Maybe<
    | EmployeePositionSubscriptionWhereInput[]
    | EmployeePositionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EmployeePositionSubscriptionWhereInput[]
    | EmployeePositionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EmployeePositionSubscriptionWhereInput[]
    | EmployeePositionSubscriptionWhereInput
  >;
}

export interface EmployeePositionTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeePositionTranslationWhereInput>;
  AND?: Maybe<
    | EmployeePositionTranslationSubscriptionWhereInput[]
    | EmployeePositionTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EmployeePositionTranslationSubscriptionWhereInput[]
    | EmployeePositionTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EmployeePositionTranslationSubscriptionWhereInput[]
    | EmployeePositionTranslationSubscriptionWhereInput
  >;
}

export interface EmployeeTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeTranslationWhereInput>;
  AND?: Maybe<
    | EmployeeTranslationSubscriptionWhereInput[]
    | EmployeeTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EmployeeTranslationSubscriptionWhereInput[]
    | EmployeeTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EmployeeTranslationSubscriptionWhereInput[]
    | EmployeeTranslationSubscriptionWhereInput
  >;
}

export interface ExpertSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpertWhereInput>;
  AND?: Maybe<ExpertSubscriptionWhereInput[] | ExpertSubscriptionWhereInput>;
  OR?: Maybe<ExpertSubscriptionWhereInput[] | ExpertSubscriptionWhereInput>;
  NOT?: Maybe<ExpertSubscriptionWhereInput[] | ExpertSubscriptionWhereInput>;
}

export interface ExpertTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpertTranslationWhereInput>;
  AND?: Maybe<
    | ExpertTranslationSubscriptionWhereInput[]
    | ExpertTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExpertTranslationSubscriptionWhereInput[]
    | ExpertTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExpertTranslationSubscriptionWhereInput[]
    | ExpertTranslationSubscriptionWhereInput
  >;
}

export interface JournalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JournalWhereInput>;
  AND?: Maybe<JournalSubscriptionWhereInput[] | JournalSubscriptionWhereInput>;
  OR?: Maybe<JournalSubscriptionWhereInput[] | JournalSubscriptionWhereInput>;
  NOT?: Maybe<JournalSubscriptionWhereInput[] | JournalSubscriptionWhereInput>;
}

export interface KeywordSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<KeywordWhereInput>;
  AND?: Maybe<KeywordSubscriptionWhereInput[] | KeywordSubscriptionWhereInput>;
  OR?: Maybe<KeywordSubscriptionWhereInput[] | KeywordSubscriptionWhereInput>;
  NOT?: Maybe<KeywordSubscriptionWhereInput[] | KeywordSubscriptionWhereInput>;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
  OR?: Maybe<LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput>;
  NOT?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
}

export interface NewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsWhereInput>;
  AND?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  OR?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  NOT?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
}

export interface NewsTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsTranslationWhereInput>;
  AND?: Maybe<
    | NewsTranslationSubscriptionWhereInput[]
    | NewsTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | NewsTranslationSubscriptionWhereInput[]
    | NewsTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | NewsTranslationSubscriptionWhereInput[]
    | NewsTranslationSubscriptionWhereInput
  >;
}

export interface OecdSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OecdWhereInput>;
  AND?: Maybe<OecdSubscriptionWhereInput[] | OecdSubscriptionWhereInput>;
  OR?: Maybe<OecdSubscriptionWhereInput[] | OecdSubscriptionWhereInput>;
  NOT?: Maybe<OecdSubscriptionWhereInput[] | OecdSubscriptionWhereInput>;
}

export interface OecdTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OecdTranslationWhereInput>;
  AND?: Maybe<
    | OecdTranslationSubscriptionWhereInput[]
    | OecdTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | OecdTranslationSubscriptionWhereInput[]
    | OecdTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | OecdTranslationSubscriptionWhereInput[]
    | OecdTranslationSubscriptionWhereInput
  >;
}

export interface QrjSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QrjWhereInput>;
  AND?: Maybe<QrjSubscriptionWhereInput[] | QrjSubscriptionWhereInput>;
  OR?: Maybe<QrjSubscriptionWhereInput[] | QrjSubscriptionWhereInput>;
  NOT?: Maybe<QrjSubscriptionWhereInput[] | QrjSubscriptionWhereInput>;
}

export interface QrjJournalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QrjJournalWhereInput>;
  AND?: Maybe<
    QrjJournalSubscriptionWhereInput[] | QrjJournalSubscriptionWhereInput
  >;
  OR?: Maybe<
    QrjJournalSubscriptionWhereInput[] | QrjJournalSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QrjJournalSubscriptionWhereInput[] | QrjJournalSubscriptionWhereInput
  >;
}

export interface QrjJournalTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QrjJournalTranslationWhereInput>;
  AND?: Maybe<
    | QrjJournalTranslationSubscriptionWhereInput[]
    | QrjJournalTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QrjJournalTranslationSubscriptionWhereInput[]
    | QrjJournalTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QrjJournalTranslationSubscriptionWhereInput[]
    | QrjJournalTranslationSubscriptionWhereInput
  >;
}

export interface QrjPublicationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QrjPublicationWhereInput>;
  AND?: Maybe<
    | QrjPublicationSubscriptionWhereInput[]
    | QrjPublicationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QrjPublicationSubscriptionWhereInput[]
    | QrjPublicationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QrjPublicationSubscriptionWhereInput[]
    | QrjPublicationSubscriptionWhereInput
  >;
}

export interface QrjPublicationTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QrjPublicationTranslationWhereInput>;
  AND?: Maybe<
    | QrjPublicationTranslationSubscriptionWhereInput[]
    | QrjPublicationTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QrjPublicationTranslationSubscriptionWhereInput[]
    | QrjPublicationTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QrjPublicationTranslationSubscriptionWhereInput[]
    | QrjPublicationTranslationSubscriptionWhereInput
  >;
}

export interface QrjTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QrjTranslationWhereInput>;
  AND?: Maybe<
    | QrjTranslationSubscriptionWhereInput[]
    | QrjTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QrjTranslationSubscriptionWhereInput[]
    | QrjTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QrjTranslationSubscriptionWhereInput[]
    | QrjTranslationSubscriptionWhereInput
  >;
}

export interface ResearchProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ResearchProjectWhereInput>;
  AND?: Maybe<
    | ResearchProjectSubscriptionWhereInput[]
    | ResearchProjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ResearchProjectSubscriptionWhereInput[]
    | ResearchProjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ResearchProjectSubscriptionWhereInput[]
    | ResearchProjectSubscriptionWhereInput
  >;
}

export interface ResearchProjectTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ResearchProjectTranslationWhereInput>;
  AND?: Maybe<
    | ResearchProjectTranslationSubscriptionWhereInput[]
    | ResearchProjectTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ResearchProjectTranslationSubscriptionWhereInput[]
    | ResearchProjectTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ResearchProjectTranslationSubscriptionWhereInput[]
    | ResearchProjectTranslationSubscriptionWhereInput
  >;
}

export interface TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TechnologyTransferAndInnovationOrganizationWhereInput>;
  AND?: Maybe<
    | TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput[]
    | TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput[]
    | TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput[]
    | TechnologyTransferAndInnovationOrganizationSubscriptionWhereInput
  >;
}

export interface TechnologyTransferNetworkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TechnologyTransferNetworkWhereInput>;
  AND?: Maybe<
    | TechnologyTransferNetworkSubscriptionWhereInput[]
    | TechnologyTransferNetworkSubscriptionWhereInput
  >;
  OR?: Maybe<
    | TechnologyTransferNetworkSubscriptionWhereInput[]
    | TechnologyTransferNetworkSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TechnologyTransferNetworkSubscriptionWhereInput[]
    | TechnologyTransferNetworkSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserTranslationWhereInput>;
  AND?: Maybe<
    | UserTranslationSubscriptionWhereInput[]
    | UserTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserTranslationSubscriptionWhereInput[]
    | UserTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserTranslationSubscriptionWhereInput[]
    | UserTranslationSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Department {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  translation: <T = FragmentableArray<DepartmentTranslation>>(args?: {
    where?: DepartmentTranslationWhereInput;
    orderBy?: DepartmentTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  translation: <
    T = Promise<AsyncIterator<DepartmentTranslationSubscription>>
  >(args?: {
    where?: DepartmentTranslationWhereInput;
    orderBy?: DepartmentTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  translation: <T = FragmentableArray<DepartmentTranslation>>(args?: {
    where?: DepartmentTranslationWhereInput;
    orderBy?: DepartmentTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DepartmentTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface DepartmentTranslationPromise
  extends Promise<DepartmentTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
  department: <T = DepartmentPromise>() => T;
}

export interface DepartmentTranslationSubscription
  extends Promise<AsyncIterator<DepartmentTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
  department: <T = DepartmentSubscription>() => T;
}

export interface DepartmentTranslationNullablePromise
  extends Promise<DepartmentTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
  department: <T = DepartmentPromise>() => T;
}

export interface Language {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: LanguageCode;
  name: String;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<LanguageCode>;
  name: () => Promise<String>;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<LanguageCode>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LanguageNullablePromise
  extends Promise<Language | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<LanguageCode>;
  name: () => Promise<String>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentTranslationConnection {
  pageInfo: PageInfo;
  edges: DepartmentTranslationEdge[];
}

export interface DepartmentTranslationConnectionPromise
  extends Promise<DepartmentTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentTranslationEdge>>() => T;
  aggregate: <T = AggregateDepartmentTranslationPromise>() => T;
}

export interface DepartmentTranslationConnectionSubscription
  extends Promise<AsyncIterator<DepartmentTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<DepartmentTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateDepartmentTranslationSubscription>() => T;
}

export interface DepartmentTranslationEdge {
  node: DepartmentTranslation;
  cursor: String;
}

export interface DepartmentTranslationEdgePromise
  extends Promise<DepartmentTranslationEdge>,
    Fragmentable {
  node: <T = DepartmentTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentTranslationEdgeSubscription
  extends Promise<AsyncIterator<DepartmentTranslationEdge>>,
    Fragmentable {
  node: <T = DepartmentTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDepartmentTranslation {
  count: Int;
}

export interface AggregateDepartmentTranslationPromise
  extends Promise<AggregateDepartmentTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentTranslationSubscription
  extends Promise<AsyncIterator<AggregateDepartmentTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Employee {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  gender: Gender;
  tel: String;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  gender: () => Promise<Gender>;
  tel: () => Promise<String>;
  department: <T = DepartmentPromise>() => T;
  position: <T = EmployeePositionPromise>() => T;
  translation: <T = FragmentableArray<EmployeeTranslation>>(args?: {
    where?: EmployeeTranslationWhereInput;
    orderBy?: EmployeeTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  tel: () => Promise<AsyncIterator<String>>;
  department: <T = DepartmentSubscription>() => T;
  position: <T = EmployeePositionSubscription>() => T;
  translation: <
    T = Promise<AsyncIterator<EmployeeTranslationSubscription>>
  >(args?: {
    where?: EmployeeTranslationWhereInput;
    orderBy?: EmployeeTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  gender: () => Promise<Gender>;
  tel: () => Promise<String>;
  department: <T = DepartmentPromise>() => T;
  position: <T = EmployeePositionPromise>() => T;
  translation: <T = FragmentableArray<EmployeeTranslation>>(args?: {
    where?: EmployeeTranslationWhereInput;
    orderBy?: EmployeeTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeePosition {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePositionPromise
  extends Promise<EmployeePosition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  translation: <T = FragmentableArray<EmployeePositionTranslation>>(args?: {
    where?: EmployeePositionTranslationWhereInput;
    orderBy?: EmployeePositionTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeePositionSubscription
  extends Promise<AsyncIterator<EmployeePosition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  translation: <
    T = Promise<AsyncIterator<EmployeePositionTranslationSubscription>>
  >(args?: {
    where?: EmployeePositionTranslationWhereInput;
    orderBy?: EmployeePositionTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeePositionNullablePromise
  extends Promise<EmployeePosition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  translation: <T = FragmentableArray<EmployeePositionTranslation>>(args?: {
    where?: EmployeePositionTranslationWhereInput;
    orderBy?: EmployeePositionTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EmployeePositionTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface EmployeePositionTranslationPromise
  extends Promise<EmployeePositionTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
  position: <T = EmployeePositionPromise>() => T;
}

export interface EmployeePositionTranslationSubscription
  extends Promise<AsyncIterator<EmployeePositionTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
  position: <T = EmployeePositionSubscription>() => T;
}

export interface EmployeePositionTranslationNullablePromise
  extends Promise<EmployeePositionTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
  position: <T = EmployeePositionPromise>() => T;
}

export interface EmployeeTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
}

export interface EmployeeTranslationPromise
  extends Promise<EmployeeTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface EmployeeTranslationSubscription
  extends Promise<AsyncIterator<EmployeeTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface EmployeeTranslationNullablePromise
  extends Promise<EmployeeTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeePositionConnection {
  pageInfo: PageInfo;
  edges: EmployeePositionEdge[];
}

export interface EmployeePositionConnectionPromise
  extends Promise<EmployeePositionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeePositionEdge>>() => T;
  aggregate: <T = AggregateEmployeePositionPromise>() => T;
}

export interface EmployeePositionConnectionSubscription
  extends Promise<AsyncIterator<EmployeePositionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeePositionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeePositionSubscription>() => T;
}

export interface EmployeePositionEdge {
  node: EmployeePosition;
  cursor: String;
}

export interface EmployeePositionEdgePromise
  extends Promise<EmployeePositionEdge>,
    Fragmentable {
  node: <T = EmployeePositionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeePositionEdgeSubscription
  extends Promise<AsyncIterator<EmployeePositionEdge>>,
    Fragmentable {
  node: <T = EmployeePositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployeePosition {
  count: Int;
}

export interface AggregateEmployeePositionPromise
  extends Promise<AggregateEmployeePosition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeePositionSubscription
  extends Promise<AsyncIterator<AggregateEmployeePosition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeePositionTranslationConnection {
  pageInfo: PageInfo;
  edges: EmployeePositionTranslationEdge[];
}

export interface EmployeePositionTranslationConnectionPromise
  extends Promise<EmployeePositionTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeePositionTranslationEdge>>() => T;
  aggregate: <T = AggregateEmployeePositionTranslationPromise>() => T;
}

export interface EmployeePositionTranslationConnectionSubscription
  extends Promise<AsyncIterator<EmployeePositionTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EmployeePositionTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEmployeePositionTranslationSubscription>() => T;
}

export interface EmployeePositionTranslationEdge {
  node: EmployeePositionTranslation;
  cursor: String;
}

export interface EmployeePositionTranslationEdgePromise
  extends Promise<EmployeePositionTranslationEdge>,
    Fragmentable {
  node: <T = EmployeePositionTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeePositionTranslationEdgeSubscription
  extends Promise<AsyncIterator<EmployeePositionTranslationEdge>>,
    Fragmentable {
  node: <T = EmployeePositionTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployeePositionTranslation {
  count: Int;
}

export interface AggregateEmployeePositionTranslationPromise
  extends Promise<AggregateEmployeePositionTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeePositionTranslationSubscription
  extends Promise<AsyncIterator<AggregateEmployeePositionTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeTranslationConnection {
  pageInfo: PageInfo;
  edges: EmployeeTranslationEdge[];
}

export interface EmployeeTranslationConnectionPromise
  extends Promise<EmployeeTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeTranslationEdge>>() => T;
  aggregate: <T = AggregateEmployeeTranslationPromise>() => T;
}

export interface EmployeeTranslationConnectionSubscription
  extends Promise<AsyncIterator<EmployeeTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EmployeeTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEmployeeTranslationSubscription>() => T;
}

export interface EmployeeTranslationEdge {
  node: EmployeeTranslation;
  cursor: String;
}

export interface EmployeeTranslationEdgePromise
  extends Promise<EmployeeTranslationEdge>,
    Fragmentable {
  node: <T = EmployeeTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeTranslationEdgeSubscription
  extends Promise<AsyncIterator<EmployeeTranslationEdge>>,
    Fragmentable {
  node: <T = EmployeeTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployeeTranslation {
  count: Int;
}

export interface AggregateEmployeeTranslationPromise
  extends Promise<AggregateEmployeeTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeTranslationSubscription
  extends Promise<AsyncIterator<AggregateEmployeeTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Expert {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  workExperience?: String;
  inpDate?: DateTimeOutput;
  email?: String;
  web?: String;
  tel?: String;
  mobile?: String;
  publications?: String;
}

export interface ExpertPromise extends Promise<Expert>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workExperience: () => Promise<String>;
  inpDate: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  web: () => Promise<String>;
  tel: () => Promise<String>;
  mobile: () => Promise<String>;
  publications: () => Promise<String>;
  translation: <T = FragmentableArray<ExpertTranslation>>(args?: {
    where?: ExpertTranslationWhereInput;
    orderBy?: ExpertTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = FragmentableArray<Oecd>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = FragmentableArray<Language>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface ExpertSubscription
  extends Promise<AsyncIterator<Expert>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  workExperience: () => Promise<AsyncIterator<String>>;
  inpDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  web: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  publications: () => Promise<AsyncIterator<String>>;
  translation: <
    T = Promise<AsyncIterator<ExpertTranslationSubscription>>
  >(args?: {
    where?: ExpertTranslationWhereInput;
    orderBy?: ExpertTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = Promise<AsyncIterator<OecdSubscription>>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = Promise<AsyncIterator<LanguageSubscription>>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface ExpertNullablePromise
  extends Promise<Expert | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workExperience: () => Promise<String>;
  inpDate: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  web: () => Promise<String>;
  tel: () => Promise<String>;
  mobile: () => Promise<String>;
  publications: () => Promise<String>;
  translation: <T = FragmentableArray<ExpertTranslation>>(args?: {
    where?: ExpertTranslationWhereInput;
    orderBy?: ExpertTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = FragmentableArray<Oecd>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  languages: <T = FragmentableArray<Language>>(args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface ExpertTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  fullName?: String;
  qualification?: String;
  academicDegree?: String;
  specialization?: String;
  workingPlace?: String;
  position?: String;
}

export interface ExpertTranslationPromise
  extends Promise<ExpertTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  fullName: () => Promise<String>;
  qualification: () => Promise<String>;
  academicDegree: () => Promise<String>;
  specialization: () => Promise<String>;
  workingPlace: () => Promise<String>;
  position: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface ExpertTranslationSubscription
  extends Promise<AsyncIterator<ExpertTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  fullName: () => Promise<AsyncIterator<String>>;
  qualification: () => Promise<AsyncIterator<String>>;
  academicDegree: () => Promise<AsyncIterator<String>>;
  specialization: () => Promise<AsyncIterator<String>>;
  workingPlace: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface ExpertTranslationNullablePromise
  extends Promise<ExpertTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  fullName: () => Promise<String>;
  qualification: () => Promise<String>;
  academicDegree: () => Promise<String>;
  specialization: () => Promise<String>;
  workingPlace: () => Promise<String>;
  position: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface Oecd {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface OecdPromise extends Promise<Oecd>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  translation: <T = FragmentableArray<OecdTranslation>>(args?: {
    where?: OecdTranslationWhereInput;
    orderBy?: OecdTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface OecdSubscription
  extends Promise<AsyncIterator<Oecd>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
  translation: <
    T = Promise<AsyncIterator<OecdTranslationSubscription>>
  >(args?: {
    where?: OecdTranslationWhereInput;
    orderBy?: OecdTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface OecdNullablePromise
  extends Promise<Oecd | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  translation: <T = FragmentableArray<OecdTranslation>>(args?: {
    where?: OecdTranslationWhereInput;
    orderBy?: OecdTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface OecdTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface OecdTranslationPromise
  extends Promise<OecdTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface OecdTranslationSubscription
  extends Promise<AsyncIterator<OecdTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface OecdTranslationNullablePromise
  extends Promise<OecdTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  password: String;
  role: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  news: <T = FragmentableArray<News>>(args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = FragmentableArray<Oecd>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  translation: <T = FragmentableArray<UserTranslation>>(args?: {
    where?: UserTranslationWhereInput;
    orderBy?: UserTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  news: <T = Promise<AsyncIterator<NewsSubscription>>>(args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = Promise<AsyncIterator<OecdSubscription>>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<AsyncIterator<Role>>;
  translation: <
    T = Promise<AsyncIterator<UserTranslationSubscription>>
  >(args?: {
    where?: UserTranslationWhereInput;
    orderBy?: UserTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  news: <T = FragmentableArray<News>>(args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = FragmentableArray<Oecd>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<Role>;
  translation: <T = FragmentableArray<UserTranslation>>(args?: {
    where?: UserTranslationWhereInput;
    orderBy?: UserTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface News {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NewsPromise extends Promise<News>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  translation: <T = FragmentableArray<NewsTranslation>>(args?: {
    where?: NewsTranslationWhereInput;
    orderBy?: NewsTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface NewsSubscription
  extends Promise<AsyncIterator<News>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  translation: <
    T = Promise<AsyncIterator<NewsTranslationSubscription>>
  >(args?: {
    where?: NewsTranslationWhereInput;
    orderBy?: NewsTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface NewsNullablePromise
  extends Promise<News | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  translation: <T = FragmentableArray<NewsTranslation>>(args?: {
    where?: NewsTranslationWhereInput;
    orderBy?: NewsTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface NewsTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  content?: String;
}

export interface NewsTranslationPromise
  extends Promise<NewsTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  content: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface NewsTranslationSubscription
  extends Promise<AsyncIterator<NewsTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface NewsTranslationNullablePromise
  extends Promise<NewsTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  content: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface UserTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
}

export interface UserTranslationPromise
  extends Promise<UserTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface UserTranslationSubscription
  extends Promise<AsyncIterator<UserTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface UserTranslationNullablePromise
  extends Promise<UserTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface ExpertConnection {
  pageInfo: PageInfo;
  edges: ExpertEdge[];
}

export interface ExpertConnectionPromise
  extends Promise<ExpertConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpertEdge>>() => T;
  aggregate: <T = AggregateExpertPromise>() => T;
}

export interface ExpertConnectionSubscription
  extends Promise<AsyncIterator<ExpertConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpertEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpertSubscription>() => T;
}

export interface ExpertEdge {
  node: Expert;
  cursor: String;
}

export interface ExpertEdgePromise extends Promise<ExpertEdge>, Fragmentable {
  node: <T = ExpertPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpertEdgeSubscription
  extends Promise<AsyncIterator<ExpertEdge>>,
    Fragmentable {
  node: <T = ExpertSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpert {
  count: Int;
}

export interface AggregateExpertPromise
  extends Promise<AggregateExpert>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpertSubscription
  extends Promise<AsyncIterator<AggregateExpert>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpertTranslationConnection {
  pageInfo: PageInfo;
  edges: ExpertTranslationEdge[];
}

export interface ExpertTranslationConnectionPromise
  extends Promise<ExpertTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpertTranslationEdge>>() => T;
  aggregate: <T = AggregateExpertTranslationPromise>() => T;
}

export interface ExpertTranslationConnectionSubscription
  extends Promise<AsyncIterator<ExpertTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpertTranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpertTranslationSubscription>() => T;
}

export interface ExpertTranslationEdge {
  node: ExpertTranslation;
  cursor: String;
}

export interface ExpertTranslationEdgePromise
  extends Promise<ExpertTranslationEdge>,
    Fragmentable {
  node: <T = ExpertTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpertTranslationEdgeSubscription
  extends Promise<AsyncIterator<ExpertTranslationEdge>>,
    Fragmentable {
  node: <T = ExpertTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpertTranslation {
  count: Int;
}

export interface AggregateExpertTranslationPromise
  extends Promise<AggregateExpertTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpertTranslationSubscription
  extends Promise<AsyncIterator<AggregateExpertTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Journal {
  id: ID_Output;
  pubNumber: String;
}

export interface JournalPromise extends Promise<Journal>, Fragmentable {
  id: () => Promise<ID_Output>;
  pubNumber: () => Promise<String>;
  translation: <T = FragmentableArray<QrjTranslation>>(args?: {
    where?: QrjTranslationWhereInput;
    orderBy?: QrjTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface JournalSubscription
  extends Promise<AsyncIterator<Journal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pubNumber: () => Promise<AsyncIterator<String>>;
  translation: <T = Promise<AsyncIterator<QrjTranslationSubscription>>>(args?: {
    where?: QrjTranslationWhereInput;
    orderBy?: QrjTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface JournalNullablePromise
  extends Promise<Journal | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pubNumber: () => Promise<String>;
  translation: <T = FragmentableArray<QrjTranslation>>(args?: {
    where?: QrjTranslationWhereInput;
    orderBy?: QrjTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QrjTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  address: String;
}

export interface QrjTranslationPromise
  extends Promise<QrjTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  address: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface QrjTranslationSubscription
  extends Promise<AsyncIterator<QrjTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  address: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface QrjTranslationNullablePromise
  extends Promise<QrjTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  address: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface JournalConnection {
  pageInfo: PageInfo;
  edges: JournalEdge[];
}

export interface JournalConnectionPromise
  extends Promise<JournalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JournalEdge>>() => T;
  aggregate: <T = AggregateJournalPromise>() => T;
}

export interface JournalConnectionSubscription
  extends Promise<AsyncIterator<JournalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JournalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJournalSubscription>() => T;
}

export interface JournalEdge {
  node: Journal;
  cursor: String;
}

export interface JournalEdgePromise extends Promise<JournalEdge>, Fragmentable {
  node: <T = JournalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JournalEdgeSubscription
  extends Promise<AsyncIterator<JournalEdge>>,
    Fragmentable {
  node: <T = JournalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJournal {
  count: Int;
}

export interface AggregateJournalPromise
  extends Promise<AggregateJournal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJournalSubscription
  extends Promise<AsyncIterator<AggregateJournal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Keyword {
  id: ID_Output;
  name?: String;
}

export interface KeywordPromise extends Promise<Keyword>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface KeywordSubscription
  extends Promise<AsyncIterator<Keyword>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface KeywordNullablePromise
  extends Promise<Keyword | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface KeywordConnection {
  pageInfo: PageInfo;
  edges: KeywordEdge[];
}

export interface KeywordConnectionPromise
  extends Promise<KeywordConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<KeywordEdge>>() => T;
  aggregate: <T = AggregateKeywordPromise>() => T;
}

export interface KeywordConnectionSubscription
  extends Promise<AsyncIterator<KeywordConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<KeywordEdgeSubscription>>>() => T;
  aggregate: <T = AggregateKeywordSubscription>() => T;
}

export interface KeywordEdge {
  node: Keyword;
  cursor: String;
}

export interface KeywordEdgePromise extends Promise<KeywordEdge>, Fragmentable {
  node: <T = KeywordPromise>() => T;
  cursor: () => Promise<String>;
}

export interface KeywordEdgeSubscription
  extends Promise<AsyncIterator<KeywordEdge>>,
    Fragmentable {
  node: <T = KeywordSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateKeyword {
  count: Int;
}

export interface AggregateKeywordPromise
  extends Promise<AggregateKeyword>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateKeywordSubscription
  extends Promise<AsyncIterator<AggregateKeyword>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LanguageConnection {
  pageInfo: PageInfo;
  edges: LanguageEdge[];
}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface LanguageEdge {
  node: Language;
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NewsConnection {
  pageInfo: PageInfo;
  edges: NewsEdge[];
}

export interface NewsConnectionPromise
  extends Promise<NewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsEdge>>() => T;
  aggregate: <T = AggregateNewsPromise>() => T;
}

export interface NewsConnectionSubscription
  extends Promise<AsyncIterator<NewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsSubscription>() => T;
}

export interface NewsEdge {
  node: News;
  cursor: String;
}

export interface NewsEdgePromise extends Promise<NewsEdge>, Fragmentable {
  node: <T = NewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsEdgeSubscription
  extends Promise<AsyncIterator<NewsEdge>>,
    Fragmentable {
  node: <T = NewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNews {
  count: Int;
}

export interface AggregateNewsPromise
  extends Promise<AggregateNews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsSubscription
  extends Promise<AsyncIterator<AggregateNews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NewsTranslationConnection {
  pageInfo: PageInfo;
  edges: NewsTranslationEdge[];
}

export interface NewsTranslationConnectionPromise
  extends Promise<NewsTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsTranslationEdge>>() => T;
  aggregate: <T = AggregateNewsTranslationPromise>() => T;
}

export interface NewsTranslationConnectionSubscription
  extends Promise<AsyncIterator<NewsTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsTranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsTranslationSubscription>() => T;
}

export interface NewsTranslationEdge {
  node: NewsTranslation;
  cursor: String;
}

export interface NewsTranslationEdgePromise
  extends Promise<NewsTranslationEdge>,
    Fragmentable {
  node: <T = NewsTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsTranslationEdgeSubscription
  extends Promise<AsyncIterator<NewsTranslationEdge>>,
    Fragmentable {
  node: <T = NewsTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNewsTranslation {
  count: Int;
}

export interface AggregateNewsTranslationPromise
  extends Promise<AggregateNewsTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsTranslationSubscription
  extends Promise<AsyncIterator<AggregateNewsTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OecdConnection {
  pageInfo: PageInfo;
  edges: OecdEdge[];
}

export interface OecdConnectionPromise
  extends Promise<OecdConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OecdEdge>>() => T;
  aggregate: <T = AggregateOecdPromise>() => T;
}

export interface OecdConnectionSubscription
  extends Promise<AsyncIterator<OecdConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OecdEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOecdSubscription>() => T;
}

export interface OecdEdge {
  node: Oecd;
  cursor: String;
}

export interface OecdEdgePromise extends Promise<OecdEdge>, Fragmentable {
  node: <T = OecdPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OecdEdgeSubscription
  extends Promise<AsyncIterator<OecdEdge>>,
    Fragmentable {
  node: <T = OecdSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOecd {
  count: Int;
}

export interface AggregateOecdPromise
  extends Promise<AggregateOecd>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOecdSubscription
  extends Promise<AsyncIterator<AggregateOecd>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OecdTranslationConnection {
  pageInfo: PageInfo;
  edges: OecdTranslationEdge[];
}

export interface OecdTranslationConnectionPromise
  extends Promise<OecdTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OecdTranslationEdge>>() => T;
  aggregate: <T = AggregateOecdTranslationPromise>() => T;
}

export interface OecdTranslationConnectionSubscription
  extends Promise<AsyncIterator<OecdTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OecdTranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOecdTranslationSubscription>() => T;
}

export interface OecdTranslationEdge {
  node: OecdTranslation;
  cursor: String;
}

export interface OecdTranslationEdgePromise
  extends Promise<OecdTranslationEdge>,
    Fragmentable {
  node: <T = OecdTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OecdTranslationEdgeSubscription
  extends Promise<AsyncIterator<OecdTranslationEdge>>,
    Fragmentable {
  node: <T = OecdTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOecdTranslation {
  count: Int;
}

export interface AggregateOecdTranslationPromise
  extends Promise<AggregateOecdTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOecdTranslationSubscription
  extends Promise<AsyncIterator<AggregateOecdTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Qrj {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: String;
}

export interface QrjPromise extends Promise<Qrj>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<String>;
  journal: <T = FragmentableArray<Journal>>(args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface QrjSubscription
  extends Promise<AsyncIterator<Qrj>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<String>>;
  journal: <T = Promise<AsyncIterator<JournalSubscription>>>(args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface QrjNullablePromise extends Promise<Qrj | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<String>;
  journal: <T = FragmentableArray<Journal>>(args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface QrjConnection {
  pageInfo: PageInfo;
  edges: QrjEdge[];
}

export interface QrjConnectionPromise
  extends Promise<QrjConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QrjEdge>>() => T;
  aggregate: <T = AggregateQrjPromise>() => T;
}

export interface QrjConnectionSubscription
  extends Promise<AsyncIterator<QrjConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QrjEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQrjSubscription>() => T;
}

export interface QrjEdge {
  node: Qrj;
  cursor: String;
}

export interface QrjEdgePromise extends Promise<QrjEdge>, Fragmentable {
  node: <T = QrjPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QrjEdgeSubscription
  extends Promise<AsyncIterator<QrjEdge>>,
    Fragmentable {
  node: <T = QrjSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQrj {
  count: Int;
}

export interface AggregateQrjPromise
  extends Promise<AggregateQrj>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQrjSubscription
  extends Promise<AsyncIterator<AggregateQrj>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QrjJournal {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface QrjJournalPromise extends Promise<QrjJournal>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  translation: <T = FragmentableArray<QrjJournalTranslation>>(args?: {
    where?: QrjJournalTranslationWhereInput;
    orderBy?: QrjJournalTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface QrjJournalSubscription
  extends Promise<AsyncIterator<QrjJournal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
  translation: <
    T = Promise<AsyncIterator<QrjJournalTranslationSubscription>>
  >(args?: {
    where?: QrjJournalTranslationWhereInput;
    orderBy?: QrjJournalTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface QrjJournalNullablePromise
  extends Promise<QrjJournal | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
  translation: <T = FragmentableArray<QrjJournalTranslation>>(args?: {
    where?: QrjJournalTranslationWhereInput;
    orderBy?: QrjJournalTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface QrjJournalTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name?: String;
  address?: String;
}

export interface QrjJournalTranslationPromise
  extends Promise<QrjJournalTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface QrjJournalTranslationSubscription
  extends Promise<AsyncIterator<QrjJournalTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface QrjJournalTranslationNullablePromise
  extends Promise<QrjJournalTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface QrjJournalConnection {
  pageInfo: PageInfo;
  edges: QrjJournalEdge[];
}

export interface QrjJournalConnectionPromise
  extends Promise<QrjJournalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QrjJournalEdge>>() => T;
  aggregate: <T = AggregateQrjJournalPromise>() => T;
}

export interface QrjJournalConnectionSubscription
  extends Promise<AsyncIterator<QrjJournalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QrjJournalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQrjJournalSubscription>() => T;
}

export interface QrjJournalEdge {
  node: QrjJournal;
  cursor: String;
}

export interface QrjJournalEdgePromise
  extends Promise<QrjJournalEdge>,
    Fragmentable {
  node: <T = QrjJournalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QrjJournalEdgeSubscription
  extends Promise<AsyncIterator<QrjJournalEdge>>,
    Fragmentable {
  node: <T = QrjJournalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQrjJournal {
  count: Int;
}

export interface AggregateQrjJournalPromise
  extends Promise<AggregateQrjJournal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQrjJournalSubscription
  extends Promise<AsyncIterator<AggregateQrjJournal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QrjJournalTranslationConnection {
  pageInfo: PageInfo;
  edges: QrjJournalTranslationEdge[];
}

export interface QrjJournalTranslationConnectionPromise
  extends Promise<QrjJournalTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QrjJournalTranslationEdge>>() => T;
  aggregate: <T = AggregateQrjJournalTranslationPromise>() => T;
}

export interface QrjJournalTranslationConnectionSubscription
  extends Promise<AsyncIterator<QrjJournalTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<QrjJournalTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateQrjJournalTranslationSubscription>() => T;
}

export interface QrjJournalTranslationEdge {
  node: QrjJournalTranslation;
  cursor: String;
}

export interface QrjJournalTranslationEdgePromise
  extends Promise<QrjJournalTranslationEdge>,
    Fragmentable {
  node: <T = QrjJournalTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QrjJournalTranslationEdgeSubscription
  extends Promise<AsyncIterator<QrjJournalTranslationEdge>>,
    Fragmentable {
  node: <T = QrjJournalTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQrjJournalTranslation {
  count: Int;
}

export interface AggregateQrjJournalTranslationPromise
  extends Promise<AggregateQrjJournalTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQrjJournalTranslationSubscription
  extends Promise<AsyncIterator<AggregateQrjJournalTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QrjPublication {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  index: String;
  edited?: Boolean;
  year?: String;
  number?: String;
  pages?: String;
  doiUrl?: String;
  inputDate?: DateTimeOutput;
}

export interface QrjPublicationPromise
  extends Promise<QrjPublication>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  index: () => Promise<String>;
  edited: () => Promise<Boolean>;
  year: () => Promise<String>;
  number: () => Promise<String>;
  pages: () => Promise<String>;
  doiUrl: () => Promise<String>;
  journal: <T = QrjJournalPromise>() => T;
  inputDate: () => Promise<DateTimeOutput>;
  oecd: <T = OecdPromise>() => T;
  translation: <T = FragmentableArray<QrjPublicationTranslation>>(args?: {
    where?: QrjPublicationTranslationWhereInput;
    orderBy?: QrjPublicationTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface QrjPublicationSubscription
  extends Promise<AsyncIterator<QrjPublication>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  index: () => Promise<AsyncIterator<String>>;
  edited: () => Promise<AsyncIterator<Boolean>>;
  year: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  pages: () => Promise<AsyncIterator<String>>;
  doiUrl: () => Promise<AsyncIterator<String>>;
  journal: <T = QrjJournalSubscription>() => T;
  inputDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  oecd: <T = OecdSubscription>() => T;
  translation: <
    T = Promise<AsyncIterator<QrjPublicationTranslationSubscription>>
  >(args?: {
    where?: QrjPublicationTranslationWhereInput;
    orderBy?: QrjPublicationTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface QrjPublicationNullablePromise
  extends Promise<QrjPublication | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  index: () => Promise<String>;
  edited: () => Promise<Boolean>;
  year: () => Promise<String>;
  number: () => Promise<String>;
  pages: () => Promise<String>;
  doiUrl: () => Promise<String>;
  journal: <T = QrjJournalPromise>() => T;
  inputDate: () => Promise<DateTimeOutput>;
  oecd: <T = OecdPromise>() => T;
  translation: <T = FragmentableArray<QrjPublicationTranslation>>(args?: {
    where?: QrjPublicationTranslationWhereInput;
    orderBy?: QrjPublicationTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface QrjPublicationTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  publicationAuthor?: String;
  publicationLang?: String;
  abstract?: String;
}

export interface QrjPublicationTranslationPromise
  extends Promise<QrjPublicationTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  publicationAuthor: () => Promise<String>;
  publicationLang: () => Promise<String>;
  abstract: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface QrjPublicationTranslationSubscription
  extends Promise<AsyncIterator<QrjPublicationTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  publicationAuthor: () => Promise<AsyncIterator<String>>;
  publicationLang: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface QrjPublicationTranslationNullablePromise
  extends Promise<QrjPublicationTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  publicationAuthor: () => Promise<String>;
  publicationLang: () => Promise<String>;
  abstract: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface QrjPublicationConnection {
  pageInfo: PageInfo;
  edges: QrjPublicationEdge[];
}

export interface QrjPublicationConnectionPromise
  extends Promise<QrjPublicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QrjPublicationEdge>>() => T;
  aggregate: <T = AggregateQrjPublicationPromise>() => T;
}

export interface QrjPublicationConnectionSubscription
  extends Promise<AsyncIterator<QrjPublicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QrjPublicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQrjPublicationSubscription>() => T;
}

export interface QrjPublicationEdge {
  node: QrjPublication;
  cursor: String;
}

export interface QrjPublicationEdgePromise
  extends Promise<QrjPublicationEdge>,
    Fragmentable {
  node: <T = QrjPublicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QrjPublicationEdgeSubscription
  extends Promise<AsyncIterator<QrjPublicationEdge>>,
    Fragmentable {
  node: <T = QrjPublicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQrjPublication {
  count: Int;
}

export interface AggregateQrjPublicationPromise
  extends Promise<AggregateQrjPublication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQrjPublicationSubscription
  extends Promise<AsyncIterator<AggregateQrjPublication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QrjPublicationTranslationConnection {
  pageInfo: PageInfo;
  edges: QrjPublicationTranslationEdge[];
}

export interface QrjPublicationTranslationConnectionPromise
  extends Promise<QrjPublicationTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QrjPublicationTranslationEdge>>() => T;
  aggregate: <T = AggregateQrjPublicationTranslationPromise>() => T;
}

export interface QrjPublicationTranslationConnectionSubscription
  extends Promise<AsyncIterator<QrjPublicationTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<QrjPublicationTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateQrjPublicationTranslationSubscription>() => T;
}

export interface QrjPublicationTranslationEdge {
  node: QrjPublicationTranslation;
  cursor: String;
}

export interface QrjPublicationTranslationEdgePromise
  extends Promise<QrjPublicationTranslationEdge>,
    Fragmentable {
  node: <T = QrjPublicationTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QrjPublicationTranslationEdgeSubscription
  extends Promise<AsyncIterator<QrjPublicationTranslationEdge>>,
    Fragmentable {
  node: <T = QrjPublicationTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQrjPublicationTranslation {
  count: Int;
}

export interface AggregateQrjPublicationTranslationPromise
  extends Promise<AggregateQrjPublicationTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQrjPublicationTranslationSubscription
  extends Promise<AsyncIterator<AggregateQrjPublicationTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QrjTranslationConnection {
  pageInfo: PageInfo;
  edges: QrjTranslationEdge[];
}

export interface QrjTranslationConnectionPromise
  extends Promise<QrjTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QrjTranslationEdge>>() => T;
  aggregate: <T = AggregateQrjTranslationPromise>() => T;
}

export interface QrjTranslationConnectionSubscription
  extends Promise<AsyncIterator<QrjTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QrjTranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQrjTranslationSubscription>() => T;
}

export interface QrjTranslationEdge {
  node: QrjTranslation;
  cursor: String;
}

export interface QrjTranslationEdgePromise
  extends Promise<QrjTranslationEdge>,
    Fragmentable {
  node: <T = QrjTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QrjTranslationEdgeSubscription
  extends Promise<AsyncIterator<QrjTranslationEdge>>,
    Fragmentable {
  node: <T = QrjTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQrjTranslation {
  count: Int;
}

export interface AggregateQrjTranslationPromise
  extends Promise<AggregateQrjTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQrjTranslationSubscription
  extends Promise<AsyncIterator<AggregateQrjTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ResearchProject {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  inpDate?: DateTimeOutput;
  regDate?: DateTimeOutput;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  regNumb?: String;
  research?: String;
  researchDirection?: String;
  researchExecutionBasis?: String;
  abstract?: String;
  annotation?: String;
  budget?: Int;
  organizationName?: String;
  organizationShortName?: String;
  organizationCode?: String;
  organizationHead?: String;
  organizationCity?: String;
  organizationAddress?: String;
  organizationIndex?: String;
  organizationTel?: String;
  organizationWeb?: String;
  participatingInstitutionName?: String;
  participatingInstitutionCountryCity?: String;
  participatingInstitutionTel?: String;
  participatingInstitutionEmail?: String;
  participatingInstitutionWeb?: String;
  leaderName?: String;
  leaderPosition?: String;
  leaderAcademicDegree?: String;
  leaderTel?: String;
  leaderMobile?: String;
  leaderEmail?: String;
  researchExecutors?: String;
  financing?: String;
  note?: String;
  pincode?: String;
}

export interface ResearchProjectPromise
  extends Promise<ResearchProject>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  inpDate: () => Promise<DateTimeOutput>;
  regDate: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  regNumb: () => Promise<String>;
  research: () => Promise<String>;
  researchDirection: () => Promise<String>;
  researchExecutionBasis: () => Promise<String>;
  abstract: () => Promise<String>;
  annotation: () => Promise<String>;
  budget: () => Promise<Int>;
  organizationName: () => Promise<String>;
  organizationShortName: () => Promise<String>;
  organizationCode: () => Promise<String>;
  organizationHead: () => Promise<String>;
  organizationCity: () => Promise<String>;
  organizationAddress: () => Promise<String>;
  organizationIndex: () => Promise<String>;
  organizationTel: () => Promise<String>;
  organizationWeb: () => Promise<String>;
  participatingInstitutionName: () => Promise<String>;
  participatingInstitutionCountryCity: () => Promise<String>;
  participatingInstitutionTel: () => Promise<String>;
  participatingInstitutionEmail: () => Promise<String>;
  participatingInstitutionWeb: () => Promise<String>;
  leaderName: () => Promise<String>;
  leaderPosition: () => Promise<String>;
  leaderAcademicDegree: () => Promise<String>;
  leaderTel: () => Promise<String>;
  leaderMobile: () => Promise<String>;
  leaderEmail: () => Promise<String>;
  researchExecutors: () => Promise<String>;
  financing: () => Promise<String>;
  note: () => Promise<String>;
  pincode: () => Promise<String>;
  translation: <T = FragmentableArray<ResearchProjectTranslation>>(args?: {
    where?: ResearchProjectTranslationWhereInput;
    orderBy?: ResearchProjectTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = FragmentableArray<Oecd>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface ResearchProjectSubscription
  extends Promise<AsyncIterator<ResearchProject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  inpDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  regDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  regNumb: () => Promise<AsyncIterator<String>>;
  research: () => Promise<AsyncIterator<String>>;
  researchDirection: () => Promise<AsyncIterator<String>>;
  researchExecutionBasis: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
  annotation: () => Promise<AsyncIterator<String>>;
  budget: () => Promise<AsyncIterator<Int>>;
  organizationName: () => Promise<AsyncIterator<String>>;
  organizationShortName: () => Promise<AsyncIterator<String>>;
  organizationCode: () => Promise<AsyncIterator<String>>;
  organizationHead: () => Promise<AsyncIterator<String>>;
  organizationCity: () => Promise<AsyncIterator<String>>;
  organizationAddress: () => Promise<AsyncIterator<String>>;
  organizationIndex: () => Promise<AsyncIterator<String>>;
  organizationTel: () => Promise<AsyncIterator<String>>;
  organizationWeb: () => Promise<AsyncIterator<String>>;
  participatingInstitutionName: () => Promise<AsyncIterator<String>>;
  participatingInstitutionCountryCity: () => Promise<AsyncIterator<String>>;
  participatingInstitutionTel: () => Promise<AsyncIterator<String>>;
  participatingInstitutionEmail: () => Promise<AsyncIterator<String>>;
  participatingInstitutionWeb: () => Promise<AsyncIterator<String>>;
  leaderName: () => Promise<AsyncIterator<String>>;
  leaderPosition: () => Promise<AsyncIterator<String>>;
  leaderAcademicDegree: () => Promise<AsyncIterator<String>>;
  leaderTel: () => Promise<AsyncIterator<String>>;
  leaderMobile: () => Promise<AsyncIterator<String>>;
  leaderEmail: () => Promise<AsyncIterator<String>>;
  researchExecutors: () => Promise<AsyncIterator<String>>;
  financing: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  pincode: () => Promise<AsyncIterator<String>>;
  translation: <
    T = Promise<AsyncIterator<ResearchProjectTranslationSubscription>>
  >(args?: {
    where?: ResearchProjectTranslationWhereInput;
    orderBy?: ResearchProjectTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = Promise<AsyncIterator<OecdSubscription>>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
}

export interface ResearchProjectNullablePromise
  extends Promise<ResearchProject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  inpDate: () => Promise<DateTimeOutput>;
  regDate: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  regNumb: () => Promise<String>;
  research: () => Promise<String>;
  researchDirection: () => Promise<String>;
  researchExecutionBasis: () => Promise<String>;
  abstract: () => Promise<String>;
  annotation: () => Promise<String>;
  budget: () => Promise<Int>;
  organizationName: () => Promise<String>;
  organizationShortName: () => Promise<String>;
  organizationCode: () => Promise<String>;
  organizationHead: () => Promise<String>;
  organizationCity: () => Promise<String>;
  organizationAddress: () => Promise<String>;
  organizationIndex: () => Promise<String>;
  organizationTel: () => Promise<String>;
  organizationWeb: () => Promise<String>;
  participatingInstitutionName: () => Promise<String>;
  participatingInstitutionCountryCity: () => Promise<String>;
  participatingInstitutionTel: () => Promise<String>;
  participatingInstitutionEmail: () => Promise<String>;
  participatingInstitutionWeb: () => Promise<String>;
  leaderName: () => Promise<String>;
  leaderPosition: () => Promise<String>;
  leaderAcademicDegree: () => Promise<String>;
  leaderTel: () => Promise<String>;
  leaderMobile: () => Promise<String>;
  leaderEmail: () => Promise<String>;
  researchExecutors: () => Promise<String>;
  financing: () => Promise<String>;
  note: () => Promise<String>;
  pincode: () => Promise<String>;
  translation: <T = FragmentableArray<ResearchProjectTranslation>>(args?: {
    where?: ResearchProjectTranslationWhereInput;
    orderBy?: ResearchProjectTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  oecds: <T = FragmentableArray<Oecd>>(args?: {
    where?: OecdWhereInput;
    orderBy?: OecdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
}

export interface ResearchProjectTranslation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
}

export interface ResearchProjectTranslationPromise
  extends Promise<ResearchProjectTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  key: <T = FragmentableArray<Keyword>>(args?: {
    where?: KeywordWhereInput;
    orderBy?: KeywordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  language: <T = LanguagePromise>() => T;
}

export interface ResearchProjectTranslationSubscription
  extends Promise<AsyncIterator<ResearchProjectTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  key: <T = Promise<AsyncIterator<KeywordSubscription>>>(args?: {
    where?: KeywordWhereInput;
    orderBy?: KeywordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  language: <T = LanguageSubscription>() => T;
}

export interface ResearchProjectTranslationNullablePromise
  extends Promise<ResearchProjectTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  key: <T = FragmentableArray<Keyword>>(args?: {
    where?: KeywordWhereInput;
    orderBy?: KeywordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  language: <T = LanguagePromise>() => T;
}

export interface ResearchProjectConnection {
  pageInfo: PageInfo;
  edges: ResearchProjectEdge[];
}

export interface ResearchProjectConnectionPromise
  extends Promise<ResearchProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResearchProjectEdge>>() => T;
  aggregate: <T = AggregateResearchProjectPromise>() => T;
}

export interface ResearchProjectConnectionSubscription
  extends Promise<AsyncIterator<ResearchProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResearchProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResearchProjectSubscription>() => T;
}

export interface ResearchProjectEdge {
  node: ResearchProject;
  cursor: String;
}

export interface ResearchProjectEdgePromise
  extends Promise<ResearchProjectEdge>,
    Fragmentable {
  node: <T = ResearchProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResearchProjectEdgeSubscription
  extends Promise<AsyncIterator<ResearchProjectEdge>>,
    Fragmentable {
  node: <T = ResearchProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResearchProject {
  count: Int;
}

export interface AggregateResearchProjectPromise
  extends Promise<AggregateResearchProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResearchProjectSubscription
  extends Promise<AsyncIterator<AggregateResearchProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ResearchProjectTranslationConnection {
  pageInfo: PageInfo;
  edges: ResearchProjectTranslationEdge[];
}

export interface ResearchProjectTranslationConnectionPromise
  extends Promise<ResearchProjectTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResearchProjectTranslationEdge>>() => T;
  aggregate: <T = AggregateResearchProjectTranslationPromise>() => T;
}

export interface ResearchProjectTranslationConnectionSubscription
  extends Promise<AsyncIterator<ResearchProjectTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ResearchProjectTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateResearchProjectTranslationSubscription>() => T;
}

export interface ResearchProjectTranslationEdge {
  node: ResearchProjectTranslation;
  cursor: String;
}

export interface ResearchProjectTranslationEdgePromise
  extends Promise<ResearchProjectTranslationEdge>,
    Fragmentable {
  node: <T = ResearchProjectTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResearchProjectTranslationEdgeSubscription
  extends Promise<AsyncIterator<ResearchProjectTranslationEdge>>,
    Fragmentable {
  node: <T = ResearchProjectTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResearchProjectTranslation {
  count: Int;
}

export interface AggregateResearchProjectTranslationPromise
  extends Promise<AggregateResearchProjectTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResearchProjectTranslationSubscription
  extends Promise<AsyncIterator<AggregateResearchProjectTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TechnologyTransferAndInnovationOrganization {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  url?: String;
  title?: String;
  text?: String;
  region?: String;
}

export interface TechnologyTransferAndInnovationOrganizationPromise
  extends Promise<TechnologyTransferAndInnovationOrganization>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  region: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface TechnologyTransferAndInnovationOrganizationSubscription
  extends Promise<AsyncIterator<TechnologyTransferAndInnovationOrganization>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface TechnologyTransferAndInnovationOrganizationNullablePromise
  extends Promise<TechnologyTransferAndInnovationOrganization | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  region: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface TechnologyTransferAndInnovationOrganizationConnection {
  pageInfo: PageInfo;
  edges: TechnologyTransferAndInnovationOrganizationEdge[];
}

export interface TechnologyTransferAndInnovationOrganizationConnectionPromise
  extends Promise<TechnologyTransferAndInnovationOrganizationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <
    T = FragmentableArray<TechnologyTransferAndInnovationOrganizationEdge>
  >() => T;
  aggregate: <
    T = AggregateTechnologyTransferAndInnovationOrganizationPromise
  >() => T;
}

export interface TechnologyTransferAndInnovationOrganizationConnectionSubscription
  extends Promise<
      AsyncIterator<TechnologyTransferAndInnovationOrganizationConnection>
    >,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<
      AsyncIterator<TechnologyTransferAndInnovationOrganizationEdgeSubscription>
    >
  >() => T;
  aggregate: <
    T = AggregateTechnologyTransferAndInnovationOrganizationSubscription
  >() => T;
}

export interface TechnologyTransferAndInnovationOrganizationEdge {
  node: TechnologyTransferAndInnovationOrganization;
  cursor: String;
}

export interface TechnologyTransferAndInnovationOrganizationEdgePromise
  extends Promise<TechnologyTransferAndInnovationOrganizationEdge>,
    Fragmentable {
  node: <T = TechnologyTransferAndInnovationOrganizationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TechnologyTransferAndInnovationOrganizationEdgeSubscription
  extends Promise<
      AsyncIterator<TechnologyTransferAndInnovationOrganizationEdge>
    >,
    Fragmentable {
  node: <T = TechnologyTransferAndInnovationOrganizationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTechnologyTransferAndInnovationOrganization {
  count: Int;
}

export interface AggregateTechnologyTransferAndInnovationOrganizationPromise
  extends Promise<AggregateTechnologyTransferAndInnovationOrganization>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTechnologyTransferAndInnovationOrganizationSubscription
  extends Promise<
      AsyncIterator<AggregateTechnologyTransferAndInnovationOrganization>
    >,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TechnologyTransferNetwork {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  url?: String;
  title?: String;
  text?: String;
  region?: String;
}

export interface TechnologyTransferNetworkPromise
  extends Promise<TechnologyTransferNetwork>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  region: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface TechnologyTransferNetworkSubscription
  extends Promise<AsyncIterator<TechnologyTransferNetwork>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface TechnologyTransferNetworkNullablePromise
  extends Promise<TechnologyTransferNetwork | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  region: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface TechnologyTransferNetworkConnection {
  pageInfo: PageInfo;
  edges: TechnologyTransferNetworkEdge[];
}

export interface TechnologyTransferNetworkConnectionPromise
  extends Promise<TechnologyTransferNetworkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TechnologyTransferNetworkEdge>>() => T;
  aggregate: <T = AggregateTechnologyTransferNetworkPromise>() => T;
}

export interface TechnologyTransferNetworkConnectionSubscription
  extends Promise<AsyncIterator<TechnologyTransferNetworkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TechnologyTransferNetworkEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTechnologyTransferNetworkSubscription>() => T;
}

export interface TechnologyTransferNetworkEdge {
  node: TechnologyTransferNetwork;
  cursor: String;
}

export interface TechnologyTransferNetworkEdgePromise
  extends Promise<TechnologyTransferNetworkEdge>,
    Fragmentable {
  node: <T = TechnologyTransferNetworkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TechnologyTransferNetworkEdgeSubscription
  extends Promise<AsyncIterator<TechnologyTransferNetworkEdge>>,
    Fragmentable {
  node: <T = TechnologyTransferNetworkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTechnologyTransferNetwork {
  count: Int;
}

export interface AggregateTechnologyTransferNetworkPromise
  extends Promise<AggregateTechnologyTransferNetwork>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTechnologyTransferNetworkSubscription
  extends Promise<AsyncIterator<AggregateTechnologyTransferNetwork>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserTranslationConnection {
  pageInfo: PageInfo;
  edges: UserTranslationEdge[];
}

export interface UserTranslationConnectionPromise
  extends Promise<UserTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserTranslationEdge>>() => T;
  aggregate: <T = AggregateUserTranslationPromise>() => T;
}

export interface UserTranslationConnectionSubscription
  extends Promise<AsyncIterator<UserTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserTranslationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserTranslationSubscription>() => T;
}

export interface UserTranslationEdge {
  node: UserTranslation;
  cursor: String;
}

export interface UserTranslationEdgePromise
  extends Promise<UserTranslationEdge>,
    Fragmentable {
  node: <T = UserTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserTranslationEdgeSubscription
  extends Promise<AsyncIterator<UserTranslationEdge>>,
    Fragmentable {
  node: <T = UserTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserTranslation {
  count: Int;
}

export interface AggregateUserTranslationPromise
  extends Promise<AggregateUserTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserTranslationSubscription
  extends Promise<AsyncIterator<AggregateUserTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DepartmentTranslationSubscriptionPayload {
  mutation: MutationType;
  node: DepartmentTranslation;
  updatedFields: String[];
  previousValues: DepartmentTranslationPreviousValues;
}

export interface DepartmentTranslationSubscriptionPayloadPromise
  extends Promise<DepartmentTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentTranslationPreviousValuesPromise>() => T;
}

export interface DepartmentTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentTranslationPreviousValuesSubscription>() => T;
}

export interface DepartmentTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface DepartmentTranslationPreviousValuesPromise
  extends Promise<DepartmentTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface DepartmentTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface EmployeePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  gender: Gender;
  tel: String;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  gender: () => Promise<Gender>;
  tel: () => Promise<String>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  tel: () => Promise<AsyncIterator<String>>;
}

export interface EmployeePositionSubscriptionPayload {
  mutation: MutationType;
  node: EmployeePosition;
  updatedFields: String[];
  previousValues: EmployeePositionPreviousValues;
}

export interface EmployeePositionSubscriptionPayloadPromise
  extends Promise<EmployeePositionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePositionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePositionPreviousValuesPromise>() => T;
}

export interface EmployeePositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeePositionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeePositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePositionPreviousValuesSubscription>() => T;
}

export interface EmployeePositionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EmployeePositionPreviousValuesPromise
  extends Promise<EmployeePositionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EmployeePositionPreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePositionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EmployeePositionTranslationSubscriptionPayload {
  mutation: MutationType;
  node: EmployeePositionTranslation;
  updatedFields: String[];
  previousValues: EmployeePositionTranslationPreviousValues;
}

export interface EmployeePositionTranslationSubscriptionPayloadPromise
  extends Promise<EmployeePositionTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePositionTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePositionTranslationPreviousValuesPromise>() => T;
}

export interface EmployeePositionTranslationSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<EmployeePositionTranslationSubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeePositionTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = EmployeePositionTranslationPreviousValuesSubscription
  >() => T;
}

export interface EmployeePositionTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface EmployeePositionTranslationPreviousValuesPromise
  extends Promise<EmployeePositionTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface EmployeePositionTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePositionTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeTranslationSubscriptionPayload {
  mutation: MutationType;
  node: EmployeeTranslation;
  updatedFields: String[];
  previousValues: EmployeeTranslationPreviousValues;
}

export interface EmployeeTranslationSubscriptionPayloadPromise
  extends Promise<EmployeeTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeeTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeeTranslationPreviousValuesPromise>() => T;
}

export interface EmployeeTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeeTranslationPreviousValuesSubscription>() => T;
}

export interface EmployeeTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
}

export interface EmployeeTranslationPreviousValuesPromise
  extends Promise<EmployeeTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface EmployeeTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeeTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

export interface ExpertSubscriptionPayload {
  mutation: MutationType;
  node: Expert;
  updatedFields: String[];
  previousValues: ExpertPreviousValues;
}

export interface ExpertSubscriptionPayloadPromise
  extends Promise<ExpertSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpertPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpertPreviousValuesPromise>() => T;
}

export interface ExpertSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpertSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpertSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpertPreviousValuesSubscription>() => T;
}

export interface ExpertPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  workExperience?: String;
  inpDate?: DateTimeOutput;
  email?: String;
  web?: String;
  tel?: String;
  mobile?: String;
  publications?: String;
}

export interface ExpertPreviousValuesPromise
  extends Promise<ExpertPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workExperience: () => Promise<String>;
  inpDate: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  web: () => Promise<String>;
  tel: () => Promise<String>;
  mobile: () => Promise<String>;
  publications: () => Promise<String>;
}

export interface ExpertPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpertPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  workExperience: () => Promise<AsyncIterator<String>>;
  inpDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  web: () => Promise<AsyncIterator<String>>;
  tel: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  publications: () => Promise<AsyncIterator<String>>;
}

export interface ExpertTranslationSubscriptionPayload {
  mutation: MutationType;
  node: ExpertTranslation;
  updatedFields: String[];
  previousValues: ExpertTranslationPreviousValues;
}

export interface ExpertTranslationSubscriptionPayloadPromise
  extends Promise<ExpertTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpertTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpertTranslationPreviousValuesPromise>() => T;
}

export interface ExpertTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpertTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpertTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpertTranslationPreviousValuesSubscription>() => T;
}

export interface ExpertTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  fullName?: String;
  qualification?: String;
  academicDegree?: String;
  specialization?: String;
  workingPlace?: String;
  position?: String;
}

export interface ExpertTranslationPreviousValuesPromise
  extends Promise<ExpertTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  fullName: () => Promise<String>;
  qualification: () => Promise<String>;
  academicDegree: () => Promise<String>;
  specialization: () => Promise<String>;
  workingPlace: () => Promise<String>;
  position: () => Promise<String>;
}

export interface ExpertTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpertTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  fullName: () => Promise<AsyncIterator<String>>;
  qualification: () => Promise<AsyncIterator<String>>;
  academicDegree: () => Promise<AsyncIterator<String>>;
  specialization: () => Promise<AsyncIterator<String>>;
  workingPlace: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface JournalSubscriptionPayload {
  mutation: MutationType;
  node: Journal;
  updatedFields: String[];
  previousValues: JournalPreviousValues;
}

export interface JournalSubscriptionPayloadPromise
  extends Promise<JournalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JournalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JournalPreviousValuesPromise>() => T;
}

export interface JournalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JournalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JournalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JournalPreviousValuesSubscription>() => T;
}

export interface JournalPreviousValues {
  id: ID_Output;
  pubNumber: String;
}

export interface JournalPreviousValuesPromise
  extends Promise<JournalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pubNumber: () => Promise<String>;
}

export interface JournalPreviousValuesSubscription
  extends Promise<AsyncIterator<JournalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pubNumber: () => Promise<AsyncIterator<String>>;
}

export interface KeywordSubscriptionPayload {
  mutation: MutationType;
  node: Keyword;
  updatedFields: String[];
  previousValues: KeywordPreviousValues;
}

export interface KeywordSubscriptionPayloadPromise
  extends Promise<KeywordSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = KeywordPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = KeywordPreviousValuesPromise>() => T;
}

export interface KeywordSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<KeywordSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = KeywordSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = KeywordPreviousValuesSubscription>() => T;
}

export interface KeywordPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface KeywordPreviousValuesPromise
  extends Promise<KeywordPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface KeywordPreviousValuesSubscription
  extends Promise<AsyncIterator<KeywordPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  node: Language;
  updatedFields: String[];
  previousValues: LanguagePreviousValues;
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface LanguagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: LanguageCode;
  name: String;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<LanguageCode>;
  name: () => Promise<String>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<LanguageCode>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface NewsSubscriptionPayload {
  mutation: MutationType;
  node: News;
  updatedFields: String[];
  previousValues: NewsPreviousValues;
}

export interface NewsSubscriptionPayloadPromise
  extends Promise<NewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsPreviousValuesPromise>() => T;
}

export interface NewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsPreviousValuesSubscription>() => T;
}

export interface NewsPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NewsPreviousValuesPromise
  extends Promise<NewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NewsPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NewsTranslationSubscriptionPayload {
  mutation: MutationType;
  node: NewsTranslation;
  updatedFields: String[];
  previousValues: NewsTranslationPreviousValues;
}

export interface NewsTranslationSubscriptionPayloadPromise
  extends Promise<NewsTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsTranslationPreviousValuesPromise>() => T;
}

export interface NewsTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsTranslationPreviousValuesSubscription>() => T;
}

export interface NewsTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  content?: String;
}

export interface NewsTranslationPreviousValuesPromise
  extends Promise<NewsTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  content: () => Promise<String>;
}

export interface NewsTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface OecdSubscriptionPayload {
  mutation: MutationType;
  node: Oecd;
  updatedFields: String[];
  previousValues: OecdPreviousValues;
}

export interface OecdSubscriptionPayloadPromise
  extends Promise<OecdSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OecdPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OecdPreviousValuesPromise>() => T;
}

export interface OecdSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OecdSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OecdSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OecdPreviousValuesSubscription>() => T;
}

export interface OecdPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface OecdPreviousValuesPromise
  extends Promise<OecdPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface OecdPreviousValuesSubscription
  extends Promise<AsyncIterator<OecdPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface OecdTranslationSubscriptionPayload {
  mutation: MutationType;
  node: OecdTranslation;
  updatedFields: String[];
  previousValues: OecdTranslationPreviousValues;
}

export interface OecdTranslationSubscriptionPayloadPromise
  extends Promise<OecdTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OecdTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OecdTranslationPreviousValuesPromise>() => T;
}

export interface OecdTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OecdTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OecdTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OecdTranslationPreviousValuesSubscription>() => T;
}

export interface OecdTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface OecdTranslationPreviousValuesPromise
  extends Promise<OecdTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface OecdTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<OecdTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface QrjSubscriptionPayload {
  mutation: MutationType;
  node: Qrj;
  updatedFields: String[];
  previousValues: QrjPreviousValues;
}

export interface QrjSubscriptionPayloadPromise
  extends Promise<QrjSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QrjPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QrjPreviousValuesPromise>() => T;
}

export interface QrjSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QrjSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QrjSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QrjPreviousValuesSubscription>() => T;
}

export interface QrjPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: String;
}

export interface QrjPreviousValuesPromise
  extends Promise<QrjPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<String>;
}

export interface QrjPreviousValuesSubscription
  extends Promise<AsyncIterator<QrjPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<String>>;
}

export interface QrjJournalSubscriptionPayload {
  mutation: MutationType;
  node: QrjJournal;
  updatedFields: String[];
  previousValues: QrjJournalPreviousValues;
}

export interface QrjJournalSubscriptionPayloadPromise
  extends Promise<QrjJournalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QrjJournalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QrjJournalPreviousValuesPromise>() => T;
}

export interface QrjJournalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QrjJournalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QrjJournalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QrjJournalPreviousValuesSubscription>() => T;
}

export interface QrjJournalPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  code: String;
}

export interface QrjJournalPreviousValuesPromise
  extends Promise<QrjJournalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface QrjJournalPreviousValuesSubscription
  extends Promise<AsyncIterator<QrjJournalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface QrjJournalTranslationSubscriptionPayload {
  mutation: MutationType;
  node: QrjJournalTranslation;
  updatedFields: String[];
  previousValues: QrjJournalTranslationPreviousValues;
}

export interface QrjJournalTranslationSubscriptionPayloadPromise
  extends Promise<QrjJournalTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QrjJournalTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QrjJournalTranslationPreviousValuesPromise>() => T;
}

export interface QrjJournalTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QrjJournalTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QrjJournalTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QrjJournalTranslationPreviousValuesSubscription>() => T;
}

export interface QrjJournalTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name?: String;
  address?: String;
}

export interface QrjJournalTranslationPreviousValuesPromise
  extends Promise<QrjJournalTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  address: () => Promise<String>;
}

export interface QrjJournalTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<QrjJournalTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface QrjPublicationSubscriptionPayload {
  mutation: MutationType;
  node: QrjPublication;
  updatedFields: String[];
  previousValues: QrjPublicationPreviousValues;
}

export interface QrjPublicationSubscriptionPayloadPromise
  extends Promise<QrjPublicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QrjPublicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QrjPublicationPreviousValuesPromise>() => T;
}

export interface QrjPublicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QrjPublicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QrjPublicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QrjPublicationPreviousValuesSubscription>() => T;
}

export interface QrjPublicationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  index: String;
  edited?: Boolean;
  year?: String;
  number?: String;
  pages?: String;
  doiUrl?: String;
  inputDate?: DateTimeOutput;
}

export interface QrjPublicationPreviousValuesPromise
  extends Promise<QrjPublicationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  index: () => Promise<String>;
  edited: () => Promise<Boolean>;
  year: () => Promise<String>;
  number: () => Promise<String>;
  pages: () => Promise<String>;
  doiUrl: () => Promise<String>;
  inputDate: () => Promise<DateTimeOutput>;
}

export interface QrjPublicationPreviousValuesSubscription
  extends Promise<AsyncIterator<QrjPublicationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  index: () => Promise<AsyncIterator<String>>;
  edited: () => Promise<AsyncIterator<Boolean>>;
  year: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<String>>;
  pages: () => Promise<AsyncIterator<String>>;
  doiUrl: () => Promise<AsyncIterator<String>>;
  inputDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QrjPublicationTranslationSubscriptionPayload {
  mutation: MutationType;
  node: QrjPublicationTranslation;
  updatedFields: String[];
  previousValues: QrjPublicationTranslationPreviousValues;
}

export interface QrjPublicationTranslationSubscriptionPayloadPromise
  extends Promise<QrjPublicationTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QrjPublicationTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QrjPublicationTranslationPreviousValuesPromise>() => T;
}

export interface QrjPublicationTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QrjPublicationTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QrjPublicationTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = QrjPublicationTranslationPreviousValuesSubscription
  >() => T;
}

export interface QrjPublicationTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  publicationAuthor?: String;
  publicationLang?: String;
  abstract?: String;
}

export interface QrjPublicationTranslationPreviousValuesPromise
  extends Promise<QrjPublicationTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  publicationAuthor: () => Promise<String>;
  publicationLang: () => Promise<String>;
  abstract: () => Promise<String>;
}

export interface QrjPublicationTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<QrjPublicationTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  publicationAuthor: () => Promise<AsyncIterator<String>>;
  publicationLang: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
}

export interface QrjTranslationSubscriptionPayload {
  mutation: MutationType;
  node: QrjTranslation;
  updatedFields: String[];
  previousValues: QrjTranslationPreviousValues;
}

export interface QrjTranslationSubscriptionPayloadPromise
  extends Promise<QrjTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QrjTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QrjTranslationPreviousValuesPromise>() => T;
}

export interface QrjTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QrjTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QrjTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QrjTranslationPreviousValuesSubscription>() => T;
}

export interface QrjTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  address: String;
}

export interface QrjTranslationPreviousValuesPromise
  extends Promise<QrjTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  address: () => Promise<String>;
}

export interface QrjTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<QrjTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface ResearchProjectSubscriptionPayload {
  mutation: MutationType;
  node: ResearchProject;
  updatedFields: String[];
  previousValues: ResearchProjectPreviousValues;
}

export interface ResearchProjectSubscriptionPayloadPromise
  extends Promise<ResearchProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResearchProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResearchProjectPreviousValuesPromise>() => T;
}

export interface ResearchProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResearchProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResearchProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResearchProjectPreviousValuesSubscription>() => T;
}

export interface ResearchProjectPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  inpDate?: DateTimeOutput;
  regDate?: DateTimeOutput;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
  regNumb?: String;
  research?: String;
  researchDirection?: String;
  researchExecutionBasis?: String;
  abstract?: String;
  annotation?: String;
  budget?: Int;
  organizationName?: String;
  organizationShortName?: String;
  organizationCode?: String;
  organizationHead?: String;
  organizationCity?: String;
  organizationAddress?: String;
  organizationIndex?: String;
  organizationTel?: String;
  organizationWeb?: String;
  participatingInstitutionName?: String;
  participatingInstitutionCountryCity?: String;
  participatingInstitutionTel?: String;
  participatingInstitutionEmail?: String;
  participatingInstitutionWeb?: String;
  leaderName?: String;
  leaderPosition?: String;
  leaderAcademicDegree?: String;
  leaderTel?: String;
  leaderMobile?: String;
  leaderEmail?: String;
  researchExecutors?: String;
  financing?: String;
  note?: String;
  pincode?: String;
}

export interface ResearchProjectPreviousValuesPromise
  extends Promise<ResearchProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  inpDate: () => Promise<DateTimeOutput>;
  regDate: () => Promise<DateTimeOutput>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  regNumb: () => Promise<String>;
  research: () => Promise<String>;
  researchDirection: () => Promise<String>;
  researchExecutionBasis: () => Promise<String>;
  abstract: () => Promise<String>;
  annotation: () => Promise<String>;
  budget: () => Promise<Int>;
  organizationName: () => Promise<String>;
  organizationShortName: () => Promise<String>;
  organizationCode: () => Promise<String>;
  organizationHead: () => Promise<String>;
  organizationCity: () => Promise<String>;
  organizationAddress: () => Promise<String>;
  organizationIndex: () => Promise<String>;
  organizationTel: () => Promise<String>;
  organizationWeb: () => Promise<String>;
  participatingInstitutionName: () => Promise<String>;
  participatingInstitutionCountryCity: () => Promise<String>;
  participatingInstitutionTel: () => Promise<String>;
  participatingInstitutionEmail: () => Promise<String>;
  participatingInstitutionWeb: () => Promise<String>;
  leaderName: () => Promise<String>;
  leaderPosition: () => Promise<String>;
  leaderAcademicDegree: () => Promise<String>;
  leaderTel: () => Promise<String>;
  leaderMobile: () => Promise<String>;
  leaderEmail: () => Promise<String>;
  researchExecutors: () => Promise<String>;
  financing: () => Promise<String>;
  note: () => Promise<String>;
  pincode: () => Promise<String>;
}

export interface ResearchProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ResearchProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  inpDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  regDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  regNumb: () => Promise<AsyncIterator<String>>;
  research: () => Promise<AsyncIterator<String>>;
  researchDirection: () => Promise<AsyncIterator<String>>;
  researchExecutionBasis: () => Promise<AsyncIterator<String>>;
  abstract: () => Promise<AsyncIterator<String>>;
  annotation: () => Promise<AsyncIterator<String>>;
  budget: () => Promise<AsyncIterator<Int>>;
  organizationName: () => Promise<AsyncIterator<String>>;
  organizationShortName: () => Promise<AsyncIterator<String>>;
  organizationCode: () => Promise<AsyncIterator<String>>;
  organizationHead: () => Promise<AsyncIterator<String>>;
  organizationCity: () => Promise<AsyncIterator<String>>;
  organizationAddress: () => Promise<AsyncIterator<String>>;
  organizationIndex: () => Promise<AsyncIterator<String>>;
  organizationTel: () => Promise<AsyncIterator<String>>;
  organizationWeb: () => Promise<AsyncIterator<String>>;
  participatingInstitutionName: () => Promise<AsyncIterator<String>>;
  participatingInstitutionCountryCity: () => Promise<AsyncIterator<String>>;
  participatingInstitutionTel: () => Promise<AsyncIterator<String>>;
  participatingInstitutionEmail: () => Promise<AsyncIterator<String>>;
  participatingInstitutionWeb: () => Promise<AsyncIterator<String>>;
  leaderName: () => Promise<AsyncIterator<String>>;
  leaderPosition: () => Promise<AsyncIterator<String>>;
  leaderAcademicDegree: () => Promise<AsyncIterator<String>>;
  leaderTel: () => Promise<AsyncIterator<String>>;
  leaderMobile: () => Promise<AsyncIterator<String>>;
  leaderEmail: () => Promise<AsyncIterator<String>>;
  researchExecutors: () => Promise<AsyncIterator<String>>;
  financing: () => Promise<AsyncIterator<String>>;
  note: () => Promise<AsyncIterator<String>>;
  pincode: () => Promise<AsyncIterator<String>>;
}

export interface ResearchProjectTranslationSubscriptionPayload {
  mutation: MutationType;
  node: ResearchProjectTranslation;
  updatedFields: String[];
  previousValues: ResearchProjectTranslationPreviousValues;
}

export interface ResearchProjectTranslationSubscriptionPayloadPromise
  extends Promise<ResearchProjectTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResearchProjectTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResearchProjectTranslationPreviousValuesPromise>() => T;
}

export interface ResearchProjectTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResearchProjectTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResearchProjectTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ResearchProjectTranslationPreviousValuesSubscription
  >() => T;
}

export interface ResearchProjectTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
}

export interface ResearchProjectTranslationPreviousValuesPromise
  extends Promise<ResearchProjectTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
}

export interface ResearchProjectTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<ResearchProjectTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface TechnologyTransferAndInnovationOrganizationSubscriptionPayload {
  mutation: MutationType;
  node: TechnologyTransferAndInnovationOrganization;
  updatedFields: String[];
  previousValues: TechnologyTransferAndInnovationOrganizationPreviousValues;
}

export interface TechnologyTransferAndInnovationOrganizationSubscriptionPayloadPromise
  extends Promise<
      TechnologyTransferAndInnovationOrganizationSubscriptionPayload
    >,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TechnologyTransferAndInnovationOrganizationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = TechnologyTransferAndInnovationOrganizationPreviousValuesPromise
  >() => T;
}

export interface TechnologyTransferAndInnovationOrganizationSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<
        TechnologyTransferAndInnovationOrganizationSubscriptionPayload
      >
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TechnologyTransferAndInnovationOrganizationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = TechnologyTransferAndInnovationOrganizationPreviousValuesSubscription
  >() => T;
}

export interface TechnologyTransferAndInnovationOrganizationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  url?: String;
  title?: String;
  text?: String;
  region?: String;
}

export interface TechnologyTransferAndInnovationOrganizationPreviousValuesPromise
  extends Promise<TechnologyTransferAndInnovationOrganizationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  region: () => Promise<String>;
}

export interface TechnologyTransferAndInnovationOrganizationPreviousValuesSubscription
  extends Promise<
      AsyncIterator<TechnologyTransferAndInnovationOrganizationPreviousValues>
    >,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
}

export interface TechnologyTransferNetworkSubscriptionPayload {
  mutation: MutationType;
  node: TechnologyTransferNetwork;
  updatedFields: String[];
  previousValues: TechnologyTransferNetworkPreviousValues;
}

export interface TechnologyTransferNetworkSubscriptionPayloadPromise
  extends Promise<TechnologyTransferNetworkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TechnologyTransferNetworkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TechnologyTransferNetworkPreviousValuesPromise>() => T;
}

export interface TechnologyTransferNetworkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TechnologyTransferNetworkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TechnologyTransferNetworkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = TechnologyTransferNetworkPreviousValuesSubscription
  >() => T;
}

export interface TechnologyTransferNetworkPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  url?: String;
  title?: String;
  text?: String;
  region?: String;
}

export interface TechnologyTransferNetworkPreviousValuesPromise
  extends Promise<TechnologyTransferNetworkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  region: () => Promise<String>;
}

export interface TechnologyTransferNetworkPreviousValuesSubscription
  extends Promise<AsyncIterator<TechnologyTransferNetworkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  password: String;
  role: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface UserTranslationSubscriptionPayload {
  mutation: MutationType;
  node: UserTranslation;
  updatedFields: String[];
  previousValues: UserTranslationPreviousValues;
}

export interface UserTranslationSubscriptionPayloadPromise
  extends Promise<UserTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserTranslationPreviousValuesPromise>() => T;
}

export interface UserTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserTranslationPreviousValuesSubscription>() => T;
}

export interface UserTranslationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
}

export interface UserTranslationPreviousValuesPromise
  extends Promise<UserTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
}

export interface UserTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<UserTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Language",
    embedded: false
  },
  {
    name: "LanguageCode",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserTranslation",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Oecd",
    embedded: false
  },
  {
    name: "OecdTranslation",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "EmployeeTranslation",
    embedded: false
  },
  {
    name: "EmployeePosition",
    embedded: false
  },
  {
    name: "EmployeePositionTranslation",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "DepartmentTranslation",
    embedded: false
  },
  {
    name: "QrjJournal",
    embedded: false
  },
  {
    name: "QrjJournalTranslation",
    embedded: false
  },
  {
    name: "News",
    embedded: false
  },
  {
    name: "NewsTranslation",
    embedded: false
  },
  {
    name: "Qrj",
    embedded: false
  },
  {
    name: "Journal",
    embedded: false
  },
  {
    name: "QrjTranslation",
    embedded: false
  },
  {
    name: "QrjPublication",
    embedded: false
  },
  {
    name: "QrjPublicationTranslation",
    embedded: false
  },
  {
    name: "Expert",
    embedded: false
  },
  {
    name: "ExpertTranslation",
    embedded: false
  },
  {
    name: "ResearchProject",
    embedded: false
  },
  {
    name: "ResearchProjectTranslation",
    embedded: false
  },
  {
    name: "Keyword",
    embedded: false
  },
  {
    name: "TechnologyTransferNetwork",
    embedded: false
  },
  {
    name: "TechnologyTransferAndInnovationOrganization",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_URL"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
